# VidSlide AI - æŠ€æœ¯å¯è¡Œæ€§åˆ†ææŠ¥å‘Š

## æ–‡æ¡£æ¦‚è¿°

**é¡¹ç›®åç§°**: VidSlide AI
**ç‰ˆæœ¬**: 1.0
**åˆ†ææ—¥æœŸ**: 2026-01-04
**åˆ†æå¸ˆ**: AI Assistant
**å®¡æ ¸äºº**: å¾…å®š

**æ ¸å¿ƒç›®æ ‡**: ç³»ç»Ÿæ€§è¯„ä¼°VidSlide AIå„é¡¹åŠŸèƒ½æ¨¡å—çš„æŠ€æœ¯å¯è¡Œæ€§ï¼Œä¸ºé¡¹ç›®å®æ–½æä¾›æŠ€æœ¯å†³ç­–ä¾æ®ã€‚

---

## ä¸€ã€æ ¸å¿ƒå·¥ä½œæµç¨‹æŠ€æœ¯åˆ†æ

### 1.1 å·¥ä½œæµç¨‹å›¾åˆ†æ

```mermaid
graph TD
    A[ä¸Šä¼ è§†é¢‘] --> B[AIå†…å®¹åˆ†æ]
    B --> C[æ™ºèƒ½å…³é”®å¸§æå–]
    C --> D[ç´ æéœ€æ±‚åˆ†æ]
    D --> E{ç´ æåŒ¹é…ç­–ç•¥}
    E -->|æœ¬åœ°åŒ¹é…åº¦â‰¥80%| F[ä½¿ç”¨æœ¬åœ°ç´ æåº“]
    E -->|æœ¬åœ°åŒ¹é…åº¦<80%| G[ç”¨æˆ·æˆæƒè¯·æ±‚]
    G -->|ç”¨æˆ·æˆæƒ| H[è·å–å¤–éƒ¨ç´ æ]
    G -->|ç”¨æˆ·æ‹’ç»| I[ä¼˜åŒ–æœ¬åœ°ç´ æ]
    F --> J[æ™ºèƒ½å‰ªè¾‘å¤„ç†]
    H --> J
    I --> J
    J --> K[æ¨¡æ¿åŒ¹é…]
    K --> L[åŠ¨æ€æ•ˆæœç”Ÿæˆ]
    L --> M[é¢„è§ˆä¸è°ƒæ•´]
    M --> N{ç”¨æˆ·æ»¡æ„?}
    N -->|æ˜¯| O[å¯¼å‡º]
    N -->|å¦| P[æ‰‹åŠ¨è°ƒæ•´]
    P --> M
```

### 1.2 å…³é”®æŠ€æœ¯èŠ‚ç‚¹è¯„ä¼°

#### 1.2.1 è§†é¢‘ä¸Šä¼ ä¸å¤„ç†
**æŠ€æœ¯æ–¹æ¡ˆ**: Web File API + WebCodecs API
- **å¯è¡Œæ€§**: â­â­â­â­â­ (é«˜)
- **æˆç†Ÿåº¦**: Web File APIå·²å¹¿æ³›æ”¯æŒï¼ŒWebCodecs APIåœ¨Chrome 94+å¯ç”¨
- **æŒ‘æˆ˜**: å¤§æ–‡ä»¶å¤„ç†å†…å­˜ç®¡ç†ï¼Œæµè§ˆå™¨å†…å­˜é™åˆ¶(é€šå¸¸2GB)
- **è§£å†³æ–¹æ¡ˆ**: åˆ†å—å¤„ç†ï¼ŒWeb Workerå¼‚æ­¥å¤„ç†

#### 1.2.2 AIå†…å®¹åˆ†æç®¡é“
**æŠ€æœ¯æ–¹æ¡ˆ**: TensorFlow.js + WebAssembly
- **å¯è¡Œæ€§**: â­â­â­â­ (è¾ƒé«˜)
- **æˆç†Ÿåº¦**: TensorFlow.jsç”Ÿæ€æˆç†Ÿï¼Œè¯­éŸ³è¯†åˆ«æ¨¡å‹å¯ç”¨
- **æŒ‘æˆ˜**: æ¨¡å‹å¤§å°(éœ€å‹ç¼©åˆ°<50MB)ï¼Œæ¨ç†æ€§èƒ½
- **è§£å†³æ–¹æ¡ˆ**: æ¨¡å‹é‡åŒ–ï¼Œä½¿ç”¨è½»é‡çº§æ¨¡å‹ï¼ŒWebAssemblyåŠ é€Ÿ

#### 1.2.3 ç´ æåŒ¹é…ç­–ç•¥
**æŠ€æœ¯æ–¹æ¡ˆ**: æ··åˆç­–ç•¥(æœ¬åœ°ä¼˜å…ˆ + æŒ‰éœ€å¤–éƒ¨è·å–)
- **å¯è¡Œæ€§**: â­â­â­â­ (è¾ƒé«˜)
- **æˆç†Ÿåº¦**: IndexedDBæˆç†Ÿï¼ŒRESTful APIè°ƒç”¨æˆç†Ÿ
- **æŒ‘æˆ˜**: ç½‘ç»œè¯·æ±‚éšç§ä¿æŠ¤ï¼Œç¼“å­˜ç­–ç•¥è®¾è®¡
- **è§£å†³æ–¹æ¡ˆ**: Service Workerç¼“å­˜ï¼Œç”¨æˆ·æˆæƒæœºåˆ¶

#### 1.2.4 æ¨¡æ¿åŒ¹é…ä¸æ¸²æŸ“
**æŠ€æœ¯æ–¹æ¡ˆ**: Canvas 2D + WebGL
- **å¯è¡Œæ€§**: â­â­â­â­â­ (é«˜)
- **æˆç†Ÿåº¦**: Canvas/WebGLå¹¿æ³›æ”¯æŒ
- **æŒ‘æˆ˜**: å¤æ‚åŠ¨ç”»åŒæ­¥ï¼Œæ€§èƒ½ä¼˜åŒ–
- **è§£å†³æ–¹æ¡ˆ**: ç¡¬ä»¶åŠ é€Ÿï¼ŒWeb Workeråˆ†æ‹…è®¡ç®—

### 1.3 æ€§èƒ½ç“¶é¢ˆåˆ†æ

| é˜¶æ®µ | é¢„æœŸè€—æ—¶ | ç“¶é¢ˆç‚¹ | ä¼˜åŒ–æ–¹æ¡ˆ |
|------|----------|--------|----------|
| **ä¸Šä¼ å¤„ç†** | 2-5ç§’ | æ–‡ä»¶éªŒè¯ | Web Workeré¢„å¤„ç† |
| **AIåˆ†æ** | 15-25ç§’ | æ¨¡å‹æ¨ç† | WebAssemblyåŠ é€Ÿ |
| **ç´ æåŒ¹é…** | 3-8ç§’ | ç½‘ç»œè¯·æ±‚ | æœ¬åœ°ç¼“å­˜ä¼˜å…ˆ |
| **æ¸²æŸ“åˆæˆ** | 2-5ç§’ | è§†é¢‘ç¼–ç  | ç¡¬ä»¶åŠ é€Ÿç¼–ç  |

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œéœ€é‡ç‚¹å…³æ³¨AIæ¨ç†æ€§èƒ½å’Œå†…å­˜ç®¡ç†

---

## äºŒã€ç”»ä¸­ç”»åŠŸèƒ½æŠ€æœ¯åˆ†æ

### 2.1 æ ¸å¿ƒæŠ€æœ¯æŒ‘æˆ˜

#### 2.1.1 è‡ªåŠ¨è§¦å‘æœºåˆ¶
**åŠŸèƒ½éœ€æ±‚**: ç´ ææ’å…¥æ—¶è‡ªåŠ¨åˆ‡æ¢ç”»ä¸­ç”»
**æŠ€æœ¯æ–¹æ¡ˆ**: è§†é¢‘æ—¶é—´è½´ç®¡ç† + çŠ¶æ€æœº
- **å¯è¡Œæ€§**: â­â­â­â­â­ (é«˜)
- **å®ç°å¤æ‚åº¦**: ä¸­ç­‰
- **å…³é”®æŠ€æœ¯**: è‡ªå®šä¹‰æ—¶é—´è½´ç»„ä»¶ï¼ŒçŠ¶æ€ç®¡ç†

#### 2.1.2 äººè„¸æ™ºèƒ½è·Ÿè¸ª
**åŠŸèƒ½éœ€æ±‚**: äººè„¸è·Ÿè¸ªï¼Œåå·®â‰¤10åƒç´ ï¼Œ1080p@25fps
**æŠ€æœ¯æ–¹æ¡ˆ**: TensorFlow.jsäººè„¸æ£€æµ‹æ¨¡å‹ + è·Ÿè¸ªç®—æ³•
- **å¯è¡Œæ€§**: â­â­â­ (ä¸­ç­‰)
- **å®ç°å¤æ‚åº¦**: é«˜
- **æŒ‘æˆ˜**:
  - æ¨¡å‹ç²¾åº¦ vs æ€§èƒ½å¹³è¡¡
  - å¤šäººè„¸åœºæ™¯ä¸»è®²äººè¯†åˆ«
  - å®æ—¶æ€§èƒ½è¦æ±‚
- **å¤‡é€‰æ–¹æ¡ˆ**: MediaPipe Face Mesh (æ›´è½»é‡)

#### 2.1.3 ç”»ä¸­ç”»æ ·å¼ç³»ç»Ÿ
**åŠŸèƒ½éœ€æ±‚**: å¤šç§æ ·å¼é…ç½®(ç®€æ´/ä¸“ä¸š/æ´»è·ƒ)
**æŠ€æœ¯æ–¹æ¡ˆ**: CSSå˜é‡ + Canvasæ¸²æŸ“
- **å¯è¡Œæ€§**: â­â­â­â­â­ (é«˜)
- **å®ç°å¤æ‚åº¦**: ä½
- **ä¼˜åŠ¿**: çµæ´»é…ç½®ï¼Œå®æ—¶åˆ‡æ¢

#### 2.1.4 è‡ªåŠ¨æ¢å¤æœºåˆ¶
**åŠŸèƒ½éœ€æ±‚**: ç´ æç»“æŸæ—¶æ— ç¼æ¢å¤å…¨å±
**æŠ€æœ¯æ–¹æ¡ˆ**: æ—¶é—´è½´äº‹ä»¶ç›‘å¬ + è¿‡æ¸¡åŠ¨ç”»
- **å¯è¡Œæ€§**: â­â­â­â­â­ (é«˜)
- **å®ç°å¤æ‚åº¦**: ä¸­ç­‰

### 2.2 æŠ€æœ¯å®ç°è·¯çº¿å›¾

```javascript
// ç”»ä¸­ç”»æ§åˆ¶å™¨æ ¸å¿ƒé€»è¾‘
class PictureInPictureController {
  constructor(videoElement, canvasElement) {
    this.video = videoElement;
    this.canvas = canvasElement;
    this.tracker = new FaceTracker();
    this.state = 'fullscreen'; // 'fullscreen' | 'pip'
  }

  // è‡ªåŠ¨è§¦å‘é€»è¾‘
  async onMaterialInsert(material, startTime, endTime) {
    // 1. æ£€æµ‹æ˜¯å¦éœ€è¦ç”»ä¸­ç”»
    if (this.shouldActivatePIP(material)) {
      await this.activatePIP(material);
      this.scheduleRecovery(endTime);
    }
  }

  // äººè„¸è·Ÿè¸ªå®ç°
  async trackFace() {
    const faces = await this.tracker.detect(this.video);
    if (faces.length > 0) {
      const mainFace = this.selectMainSpeaker(faces);
      this.updatePIPPosition(mainFace);
    }
  }
}
```

### 2.3 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

| ä¼˜åŒ–ç‚¹ | å½“å‰æ€§èƒ½ | ç›®æ ‡æ€§èƒ½ | æ–¹æ¡ˆ |
|--------|----------|----------|------|
| **äººè„¸æ£€æµ‹** | ~100ms | â‰¤40ms | æ¨¡å‹ä¼˜åŒ–ï¼ŒROIæ£€æµ‹ |
| **ä½ç½®æ›´æ–°** | ~16ms | â‰¤8ms | æ’å€¼ç®—æ³•ï¼Œå‡å°‘è®¡ç®— |
| **å†…å­˜å ç”¨** | ~50MB | â‰¤20MB | æ¨¡å‹å‹ç¼©ï¼Œèµ„æºå¤ç”¨ |

**æ€»ä½“è¯„ä¼°**: âš ï¸ **æ¡ä»¶å¯è¡Œ**ï¼Œäººè„¸è·Ÿè¸ªæ˜¯æœ€å¤§æŠ€æœ¯é£é™©ï¼Œå»ºè®®MVPé˜¶æ®µå…ˆå®ç°åŸºç¡€ç”»ä¸­ç”»ï¼Œåç»­å‡çº§AIè·Ÿè¸ª

---

## ä¸‰ã€AIå†…å®¹åˆ†ææŠ€æœ¯åˆ†æ

### 3.1 è¯­éŸ³è¯†åˆ«æ¨¡å—

#### 3.1.1 æŠ€æœ¯æ–¹æ¡ˆé€‰æ‹©
**ä¸»æµæ–¹æ¡ˆå¯¹æ¯”**:

| æ–¹æ¡ˆ | ä¼˜åŠ¿ | åŠ£åŠ¿ | å¯è¡Œæ€§ |
|------|------|------|--------|
| **Web Speech API** | åŸç”Ÿæ”¯æŒï¼Œå…è´¹ | å‡†ç¡®ç‡ä½ï¼Œä»…Chrome | â­â­ (ä½) |
| **Azure Speech** | é«˜å‡†ç¡®ç‡ï¼Œå¤šè¯­è¨€ | éœ€è¦APIå¯†é’¥ï¼Œæˆæœ¬ | â­â­â­â­ (è¾ƒé«˜) |
| **Coqui STT** | æœ¬åœ°åŒ–ï¼Œéšç§å‹å¥½ | æ¨¡å‹å¤§ï¼Œé¦–æ¬¡åŠ è½½æ…¢ | â­â­â­â­â­ (é«˜) |
| **TensorFlow.js** | å®Œå…¨æœ¬åœ°ï¼Œå®šåˆ¶åŒ– | å¼€å‘å¤æ‚åº¦é«˜ | â­â­â­â­ (è¾ƒé«˜) |

**æ¨èæ–¹æ¡ˆ**: Coqui STT + æœ¬åœ°æ¨¡å‹ï¼Œç»“åˆAzureä½œä¸ºå¤‡é€‰

#### 3.1.2 å¤šè¯­è¨€æ”¯æŒå®ç°
```javascript
// å¤šè¯­è¨€è¯­éŸ³è¯†åˆ«ç®¡ç†å™¨
class SpeechRecognitionManager {
  constructor() {
    this.models = {
      'zh-CN': new CoquiModel('zh-CN'),
      'en-US': new CoquiModel('en-US'),
      'ja-JP': new CoquiModel('ja-JP')
    };
    this.fallback = new AzureSpeechService();
  }

  async recognize(audioBlob, language) {
    try {
      // ä¼˜å…ˆä½¿ç”¨æœ¬åœ°æ¨¡å‹
      const result = await this.models[language].transcribe(audioBlob);
      return result;
    } catch (error) {
      // é™çº§åˆ°äº‘æœåŠ¡
      return await this.fallback.recognize(audioBlob, language);
    }
  }
}
```

#### 3.1.3 å™ªå£°å¤„ç†æŠ€æœ¯
**æŠ€æœ¯æ–¹æ¡ˆ**: Web Audio API + RNNoise
- **å¯è¡Œæ€§**: â­â­â­â­ (è¾ƒé«˜)
- **å®ç°**: éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„ç†ï¼Œå®æ—¶é™å™ª

### 3.2 é‡ç‚¹æå–æ¨¡å—

#### 3.2.1 å…³é”®è¯æå–ç®—æ³•
**æŠ€æœ¯æ–¹æ¡ˆ**: TF-IDF + TextRank + è§„åˆ™å¼•æ“
```javascript
class KeywordExtractor {
  async extract(text, language) {
    // 1. åˆ†è¯å¤„ç†
    const tokens = await this.tokenizer.tokenize(text, language);

    // 2. TF-IDFè®¡ç®—
    const tfidf = this.tfidf.compute(tokens);

    // 3. TextRankæ’åº
    const keywords = this.textRank.rank(tokens, tfidf);

    // 4. è§„åˆ™è¿‡æ»¤
    return this.filterByRules(keywords);
  }
}
```

#### 3.2.2 æ—¶é—´çº¿è¯†åˆ«
**æ­£åˆ™è¡¨è¾¾å¼ + NLPæ¨¡å¼åŒ¹é…**:
```javascript
const timePatterns = {
  yearSequence: /\b(20\d{2})[^\d]*?(20\d{2})\b/g,
  yearMonth: /\b(20\d{2})å¹´(\d{1,2})æœˆ\b/g,
  relativeTime: /\b(å»å¹´|ä»Šå¹´|æ˜å¹´|ä¸Šä¸ªæœˆ|è¿™ä¸ªæœˆ)\b/g
};
```

### 3.3 å›¾è¡¨éœ€æ±‚è¯†åˆ«
**åŸºäºå…³é”®è¯å’Œä¸Šä¸‹æ–‡åˆ†æ**:
```javascript
const chartKeywords = {
  trend: ['å¢é•¿', 'ä¸‹é™', 'è¶‹åŠ¿', 'å˜åŒ–'],
  comparison: ['å¯¹æ¯”', 'æ¯”è¾ƒ', 'å·®å¼‚'],
  distribution: ['åˆ†å¸ƒ', 'å æ¯”', 'æ¯”ä¾‹'],
  correlation: ['å…³ç³»', 'ç›¸å…³', 'å…³è”']
};
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œè¯­éŸ³è¯†åˆ«æ˜¯æœ€å¤§æŒ‘æˆ˜ï¼Œå»ºè®®é‡‡ç”¨æ··åˆæ–¹æ¡ˆ(æœ¬åœ°ä¼˜å…ˆ+äº‘ç«¯å¤‡é€‰)

---

## å››ã€ç´ æè·å–ä¸å‰ªè¾‘æŠ€æœ¯åˆ†æ

### 4.1 æ··åˆç´ æç­–ç•¥

#### 4.1.1 æœ¬åœ°ç´ æåº“è®¾è®¡
**å­˜å‚¨æ–¹æ¡ˆ**: IndexedDB + æ–‡ä»¶ç³»ç»ŸAPI
```javascript
class LocalAssetLibrary {
  constructor() {
    this.db = new IndexedDB('vidslide-assets');
    this.categories = ['icons', 'charts', 'backgrounds', 'education', 'tech'];
  }

  async preloadAssets() {
    // é¢„åŠ è½½1000+åŸºç¡€ç´ æ
    const assets = await fetch('/assets/preload-manifest.json');
    for (const asset of assets) {
      await this.storeAsset(asset);
    }
  }

  async search(keyword, category = null) {
    // æœ¬åœ°è¯­ä¹‰æœç´¢
    return await this.db.search('assets', {
      keyword,
      category,
      minScore: 0.7
    });
  }
}
```

#### 4.1.2 å¤–éƒ¨ç´ æAPIé›†æˆ
**APIé€‰æ‹©æ ‡å‡†**:
1. å…ç‰ˆç¨ï¼Œå¯å•†ä¸šä½¿ç”¨
2. æä¾›æœç´¢API
3. æ”¯æŒå…³é”®è¯æœç´¢
4. æœ‰æ˜ç¡®çš„æˆæƒæ ‡è¯†

**æ¨èAPIç»„åˆ**:
- **Unsplash**: é«˜è´¨é‡ç…§ç‰‡ï¼ŒAPIç¨³å®š
- **Pexels**: è§†é¢‘ç´ æè¡¥å……
- **Pixabay**: å…è´¹ç´ æï¼Œç§ç±»ä¸°å¯Œ

#### 4.1.3 ç”¨æˆ·æˆæƒæœºåˆ¶
```javascript
class ExternalAssetService {
  async requestAuthorization(keyword) {
    const dialog = new AuthorizationDialog({
      keyword,
      apis: ['Unsplash', 'Pexels', 'Pixabay'],
      purpose: 'è·å–ç›¸å…³ç´ æä»¥å¢å¼ºæ¼”ç¤ºæ•ˆæœ'
    });

    const authorized = await dialog.show();
    if (authorized) {
      return await this.searchAndDownload(keyword);
    }
    return null;
  }
}
```

### 4.2 ç´ æåŒ¹é…ç®—æ³•

#### 4.2.1 è¯­ä¹‰åŒ¹é…å®ç°
**æŠ€æœ¯æ–¹æ¡ˆ**: CLIPæ¨¡å‹ + æœ¬åœ°åŒ–ä¼˜åŒ–
```javascript
class SemanticMatcher {
  constructor() {
    this.clip = new CLIPModel();
    this.cache = new LRUCache(1000);
  }

  async match(text, images) {
    // 1. æ–‡æœ¬ç¼–ç 
    const textEmbedding = await this.clip.encodeText(text);

    // 2. æ‰¹é‡å›¾åƒç¼–ç 
    const imageEmbeddings = await this.clip.encodeImages(images);

    // 3. ç›¸ä¼¼åº¦è®¡ç®—
    const similarities = imageEmbeddings.map(emb =>
      this.cosineSimilarity(textEmbedding, emb)
    );

    return similarities;
  }
}
```

#### 4.2.2 æ€§èƒ½ä¼˜åŒ–
- **é¢„è®¡ç®—åµŒå…¥**: ç´ æåº“é¢„è®¡ç®—ç‰¹å¾å‘é‡
- **è¿‘ä¼¼æœç´¢**: ä½¿ç”¨HNSWç®—æ³•åŠ é€Ÿæœç´¢
- **ç¼“å­˜ç­–ç•¥**: LRUç¼“å­˜çƒ­ç‚¹æŸ¥è¯¢ç»“æœ

### 4.3 å‰ªè¾‘å¤„ç†æŠ€æœ¯

#### 4.3.1 è‡ªåŠ¨è£å‰ª
**æŠ€æœ¯æ–¹æ¡ˆ**: OpenCV.js + WebAssembly
```javascript
class ImageProcessor {
  async smartCrop(imageData, targetRatio) {
    // 1. ä¸»ä½“æ£€æµ‹
    const subjects = await this.detectSubjects(imageData);

    // 2. æ™ºèƒ½è£å‰ª
    const cropRegion = this.calculateCropRegion(subjects, targetRatio);

    // 3. ä¿æŒæ¯”ä¾‹å¡«å……
    return this.cropAndFill(imageData, cropRegion);
  }
}
```

#### 4.3.2 èƒŒæ™¯å¤„ç†
**æ–¹æ¡ˆé€‰æ‹©**:
- **è½»é‡çº§**: BodyPixäººä½“åˆ†å‰²
- **ä¸“ä¸šçº§**: DeepLab v3è¯­ä¹‰åˆ†å‰²
- **å¤‡é€‰**: ä¼ ç»Ÿå›¾åƒå¤„ç†ç®—æ³•

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œé‡ç‚¹å…³æ³¨éšç§ä¿æŠ¤å’Œæ€§èƒ½å¹³è¡¡

---

## äº”ã€æ¨¡æ¿ç³»ç»ŸæŠ€æœ¯åˆ†æ

### 5.1 æ¨¡æ¿æ¶æ„è®¾è®¡

#### 5.1.1 å±‚çº§ç»“æ„å®ç°
**æ¨¡æ¿å®šä¹‰æ ¼å¼**:
```json
{
  "id": "picture-in-picture",
  "name": "ç”»ä¸­ç”»æ¨¡æ¿",
  "layers": [
    {
      "id": "background-overlay",
      "type": "fixed",
      "zIndex": 1,
      "properties": {
        "opacity": 0.4,
        "color": "#000000"
      }
    },
    {
      "id": "pip-container",
      "type": "fixed",
      "zIndex": 2,
      "properties": {
        "position": "top-right",
        "size": "25%",
        "shape": "circle"
      }
    },
    {
      "id": "face-tracking",
      "type": "dynamic",
      "zIndex": 3,
      "properties": {
        "accuracy": 10,
        "smoothness": 0.8
      }
    }
  ]
}
```

#### 5.1.2 æ¨¡æ¿è§£æå™¨
```javascript
class TemplateParser {
  parse(templateJson) {
    const template = JSON.parse(templateJson);

    return {
      fixedLayers: template.layers.filter(l => l.type === 'fixed'),
      dynamicLayers: template.layers.filter(l => l.type === 'dynamic'),
      adjustableLayers: template.layers.filter(l => l.type === 'adjustable')
    };
  }
}
```

### 5.2 çº¦æŸç³»ç»Ÿè®¾è®¡

#### 5.2.1 çº¦æŸè§„åˆ™å®šä¹‰
```javascript
const constraints = {
  'pip-container': {
    size: { min: 0.1, max: 0.5 },
    position: ['top-left', 'top-right', 'bottom-left', 'bottom-right'],
    shape: ['circle', 'rounded-rectangle']
  },
  'text-content': {
    maxLength: 20,
    allowedChars: /^[a-zA-Z0-9\u4e00-\u9fa5\s]+$/
  }
};
```

#### 5.2.2 çº¦æŸéªŒè¯å™¨
```javascript
class ConstraintValidator {
  validate(layerId, property, value) {
    const constraint = this.constraints[layerId]?.[property];
    if (!constraint) return { valid: true };

    switch (property) {
      case 'size':
        return this.validateRange(value, constraint.min, constraint.max);
      case 'position':
        return this.validateEnum(value, constraint);
      default:
        return { valid: true };
    }
  }
}
```

### 5.3 æ¨¡æ¿æ¸²æŸ“å¼•æ“

#### 5.3.1 æ¸²æŸ“ç®¡é“
```javascript
class TemplateRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.layers = [];
  }

  async render(template, data) {
    // 1. æ¸…ç©ºç”»å¸ƒ
    this.clear();

    // 2. æŒ‰z-indexæ’åºæ¸²æŸ“
    const sortedLayers = this.sortLayers(template.layers);

    // 3. é€å±‚æ¸²æŸ“
    for (const layer of sortedLayers) {
      await this.renderLayer(layer, data);
    }
  }

  async renderLayer(layer, data) {
    switch (layer.type) {
      case 'background':
        this.renderBackground(layer);
        break;
      case 'pip':
        await this.renderPictureInPicture(layer, data.video);
        break;
      case 'text':
        this.renderText(layer, data.text);
        break;
    }
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œæ¨¡æ¿ç³»ç»Ÿæ¶æ„æ¸…æ™°ï¼Œå®ç°å¤æ‚åº¦é€‚ä¸­

---

## äº”ç‚¹äº”ã€ç´ æè·å–ä¸å‰ªè¾‘æŠ€æœ¯åˆ†æ

### 5.5.1 æ··åˆç´ æç­–ç•¥å®ç°

#### 5.5.1.1 æœ¬åœ°ç´ æåº“æ¶æ„
**å­˜å‚¨è®¾è®¡**:
```javascript
class LocalAssetManager {
  constructor() {
    this.dbVersion = 1;
    this.db = null;
    this.stores = {
      assets: 'assets',
      metadata: 'metadata',
      cache: 'cache'
    };
  }

  async init() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open('VidSlideAssets', this.dbVersion);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;

        // ç´ æå­˜å‚¨
        if (!db.objectStoreNames.contains(this.stores.assets)) {
          const assetStore = db.createObjectStore(this.stores.assets, { keyPath: 'id' });
          assetStore.createIndex('category', 'category', { unique: false });
          assetStore.createIndex('tags', 'tags', { unique: false, multiEntry: true });
          assetStore.createIndex('type', 'type', { unique: false });
        }

        // å…ƒæ•°æ®å­˜å‚¨
        if (!db.objectStoreNames.contains(this.stores.metadata)) {
          const metadataStore = db.createObjectStore(this.stores.metadata, { keyPath: 'id' });
          metadataStore.createIndex('lastUsed', 'lastUsed', { unique: false });
          metadataStore.createIndex('usageCount', 'usageCount', { unique: false });
        }
      };
    });
  }

  async preloadBaseAssets() {
    const manifest = await fetch('/assets/manifest.json').then(r => r.json());

    for (const category of manifest.categories) {
      for (const asset of category.assets) {
        await this.storeAsset({
          id: asset.id,
          category: category.name,
          type: asset.type,
          url: asset.url,
          tags: asset.tags,
          metadata: asset.metadata
        });
      }
    }
  }
}
```

#### 5.5.1.2 å¤–éƒ¨ç´ æé›†æˆæ–¹æ¡ˆ
**APIæŠ½è±¡å±‚è®¾è®¡**:
```javascript
class ExternalAssetProvider {
  constructor(apiKey, baseUrl) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.rateLimiter = new RateLimiter(50, 'minute'); // 50è¯·æ±‚/åˆ†é’Ÿ
  }

  async search(query, options = {}) {
    await this.rateLimiter.waitForSlot();

    const params = new URLSearchParams({
      query: query.keyword,
      per_page: options.limit || 12,
      orientation: options.orientation || 'landscape',
      ...options.filters
    });

    const response = await fetch(`${this.baseUrl}/search?${params}`, {
      headers: {
        'Authorization': `Client-ID ${this.apiKey}`,
        'Accept-Version': 'v1'
      }
    });

    return await response.json();
  }

  async downloadImage(imageId, size = 'regular') {
    const response = await fetch(`${this.baseUrl}/photos/${imageId}?w=800&h=600`, {
      headers: {
        'Authorization': `Client-ID ${this.apiKey}`
      }
    });

    const blob = await response.blob();
    return new File([blob], `image-${imageId}.jpg`, { type: 'image/jpeg' });
  }
}

// å¤šAPIç®¡ç†å™¨
class AssetAggregator {
  constructor() {
    this.providers = {
      unsplash: new ExternalAssetProvider(UNPLASH_KEY, 'https://api.unsplash.com'),
      pexels: new ExternalAssetProvider(PEXELS_KEY, 'https://api.pexels.com/v1'),
      pixabay: new ExternalAssetProvider(PIXABAY_KEY, 'https://pixabay.com/api')
    };
  }

  async searchAll(keyword, options = {}) {
    const promises = Object.values(this.providers).map(provider =>
      provider.search({ keyword }, options).catch(() => [])
    );

    const results = await Promise.all(promises);
    return this.mergeAndRank(results.flat());
  }

  mergeAndRank(results) {
    // æŒ‰ç›¸å…³åº¦ã€è´¨é‡ã€æˆæƒç±»å‹æ’åº
    return results.sort((a, b) => {
      // ä¼˜å…ˆçº§: å…ç‰ˆç¨ > è´¨é‡è¯„åˆ† > ä¸‹è½½æ¬¡æ•°
      const scoreA = this.calculateScore(a);
      const scoreB = this.calculateScore(b);
      return scoreB - scoreA;
    });
  }
}
```

#### 5.5.1.3 ç”¨æˆ·æˆæƒæµç¨‹
**æ¸è¿›å¼æƒé™è®¾è®¡**:
```javascript
class AuthorizationWorkflow {
  constructor() {
    this.permissionLevels = {
      none: 0,        // æ— æƒé™
      local: 1,       // ä»…æœ¬åœ°ç´ æ
      preview: 2,     // å¯é¢„è§ˆå¤–éƒ¨ç´ æ
      download: 3     // å¯ä¸‹è½½å¤–éƒ¨ç´ æ
    };
  }

  async requestProgressiveAccess(keyword, purpose) {
    // ç¬¬ä¸€æ­¥ï¼šè§£é‡Šéœ€è¦å¤–éƒ¨ç´ æçš„åŸå› 
    const explained = await this.showExplanationDialog(keyword, purpose);
    if (!explained) return this.permissionLevels.local;

    // ç¬¬äºŒæ­¥ï¼šå±•ç¤ºå°†ä½¿ç”¨çš„API
    const apis = this.determineRequiredAPIs(keyword);
    const apiApproved = await this.showApiDialog(apis);
    if (!apiApproved) return this.permissionLevels.local;

    // ç¬¬ä¸‰æ­¥ï¼šç¡®è®¤å•æ¬¡ä½¿ç”¨
    const sessionApproved = await this.showSessionDialog();
    if (!sessionApproved) return this.permissionLevels.local;

    // ç¬¬å››æ­¥ï¼šæˆäºˆæƒé™å¹¶ç¼“å­˜
    await this.grantPermission(apis, 'session');
    return this.permissionLevels.download;
  }

  async showExplanationDialog(keyword, purpose) {
    return new Promise(resolve => {
      const dialog = new AuthorizationDialog({
        title: 'éœ€è¦è·å–å¤–éƒ¨ç´ æ',
        content: `
          ä¸ºäº†ç”Ÿæˆæ›´å¥½çš„æ¼”ç¤ºæ•ˆæœï¼Œç³»ç»Ÿéœ€è¦æœç´¢å…³é”®è¯"${keyword}"çš„ç›¸å…³å›¾ç‰‡ã€‚
          è¿™å°†å¸®åŠ©åˆ›å»ºæ›´ä¸“ä¸šçš„è§†è§‰å‘ˆç°ã€‚

          â€¢ ä»…ä½¿ç”¨å…³é”®è¯è¿›è¡Œæœç´¢
          â€¢ ä¸ä¸Šä¼ æ‚¨çš„è§†é¢‘å†…å®¹
          â€¢ ä»…åœ¨å½“å‰ä¼šè¯ä¸­ä½¿ç”¨æœç´¢ç»“æœ
        `,
        buttons: ['ä½¿ç”¨æœ¬åœ°ç´ æ', 'ç»§ç»­æˆæƒ']
      });

      dialog.onConfirm = () => resolve(true);
      dialog.onCancel = () => resolve(false);
      dialog.show();
    });
  }
}
```

### 5.5.2 ç´ æåŒ¹é…ç®—æ³•ä¼˜åŒ–

#### 5.5.2.1 è¯­ä¹‰åŒ¹é…å®ç°
**CLIPæ¨¡å‹é›†æˆ**:
```javascript
class SemanticMatcher {
  constructor() {
    this.model = null;
    this.textCache = new Map();
    this.imageCache = new Map();
  }

  async loadModel() {
    // åŠ è½½è½»é‡çº§CLIPæ¨¡å‹
    this.model = await tf.loadGraphModel('/models/clip/model.json');
  }

  async encodeText(text) {
    if (this.textCache.has(text)) {
      return this.textCache.get(text);
    }

    const tokens = await this.tokenize(text);
    const embedding = await this.model.executeAsync(tokens);
    const normalized = tf.div(embedding, tf.norm(embedding));

    this.textCache.set(text, normalized);
    return normalized;
  }

  async encodeImage(imageElement) {
    const cacheKey = imageElement.src;
    if (this.imageCache.has(cacheKey)) {
      return this.imageCache.get(cacheKey);
    }

    // é¢„å¤„ç†å›¾åƒ
    const tensor = tf.browser.fromPixels(imageElement)
      .resizeNearestNeighbor([224, 224])
      .div(255.0)
      .expandDims(0);

    const embedding = await this.model.executeAsync(tensor);
    const normalized = tf.div(embedding, tf.norm(embedding));

    this.imageCache.set(cacheKey, normalized);
    return normalized;
  }

  async match(text, images) {
    const textEmbedding = await this.encodeText(text);
    const imageEmbeddings = await Promise.all(
      images.map(img => this.encodeImage(img))
    );

    const similarities = imageEmbeddings.map(imgEmb =>
      tf.matMul(textEmbedding, imgEmb, false, true).dataSync()[0]
    );

    return similarities.map((sim, index) => ({
      image: images[index],
      similarity: sim,
      confidence: this.calculateConfidence(sim)
    }));
  }

  calculateConfidence(similarity) {
    // å°†ç›¸ä¼¼åº¦è½¬æ¢ä¸ºç½®ä¿¡åº¦è¯„åˆ†(0-100)
    return Math.round((similarity + 1) * 50);
  }
}
```

#### 5.5.2.2 å¤šå±‚çº§åŒ¹é…ç­–ç•¥
```javascript
class MultiLevelMatcher {
  constructor() {
    this.semanticMatcher = new SemanticMatcher();
    this.keywordMatcher = new KeywordMatcher();
    this.categoryMatcher = new CategoryMatcher();
  }

  async match(text, images, context = {}) {
    const results = [];

    for (const image of images) {
      const scores = await Promise.all([
        this.semanticMatcher.match(text, [image]),
        this.keywordMatcher.match(text, image),
        this.categoryMatcher.match(context.category, image)
      ]);

      const finalScore = this.combineScores(scores);
      results.push({
        image,
        score: finalScore,
        confidence: Math.min(finalScore * 100, 100)
      });
    }

    return results.sort((a, b) => b.score - a.score);
  }

  combineScores([semantic, keyword, category]) {
    // åŠ æƒç»„åˆ: è¯­ä¹‰60% + å…³é”®è¯30% + ç±»åˆ«10%
    return semantic * 0.6 + keyword * 0.3 + category * 0.1;
  }
}
```

### 5.5.3 å‰ªè¾‘å¤„ç†æŠ€æœ¯

#### 5.5.3.1 æ™ºèƒ½è£å‰ªç®—æ³•
**åŸºäºå†…å®¹çš„å¯è§†è£å‰ª**:
```javascript
class SmartCropper {
  constructor() {
    this.detector = new ObjectDetector();
  }

  async crop(imageData, targetAspectRatio, options = {}) {
    // 1. æ£€æµ‹å›¾åƒä¸­çš„æ˜¾è‘—åŒºåŸŸ
    const salientRegions = await this.detectSalientRegions(imageData);

    // 2. è¯†åˆ«ä¸»ä½“å†…å®¹
    const subjects = await this.detectSubjects(imageData);

    // 3. è®¡ç®—æœ€ä½³è£å‰ªåŒºåŸŸ
    const cropRegion = this.calculateOptimalCrop(
      salientRegions,
      subjects,
      targetAspectRatio,
      options
    );

    // 4. æ‰§è¡Œè£å‰ªå¹¶æ™ºèƒ½å¡«å……
    return this.applyCrop(imageData, cropRegion, options);
  }

  async detectSalientRegions(imageData) {
    // ä½¿ç”¨ä¼ ç»ŸCVæ–¹æ³•æˆ–æ·±åº¦å­¦ä¹ æ¨¡å‹
    const saliencyMap = await this.computeSaliencyMap(imageData);
    return this.extractRegions(saliencyMap);
  }

  calculateOptimalCrop(salientRegions, subjects, targetRatio, options) {
    // åŸºäºæ˜¾è‘—æ€§å’Œä¸»ä½“ä½ç½®è®¡ç®—æœ€ä½³è£å‰ªæ¡†
    const candidates = this.generateCropCandidates(
      salientRegions,
      subjects,
      targetRatio
    );

    return candidates.reduce((best, current) => {
      const bestScore = this.scoreCrop(best, salientRegions, subjects);
      const currentScore = this.scoreCrop(current, salientRegions, subjects);
      return currentScore > bestScore ? current : best;
    });
  }

  scoreCrop(cropRegion, salientRegions, subjects) {
    // è£å‰ªè¯„åˆ†: æ˜¾è‘—æ€§è¦†ç›– + ä¸»ä½“å®Œæ•´æ€§ + æ„å›¾å¹³è¡¡
    const saliencyCoverage = this.calculateSaliencyCoverage(cropRegion, salientRegions);
    const subjectIntegrity = this.calculateSubjectIntegrity(cropRegion, subjects);
    const compositionBalance = this.calculateCompositionBalance(cropRegion);

    return saliencyCoverage * 0.5 + subjectIntegrity * 0.3 + compositionBalance * 0.2;
  }
}
```

#### 5.5.3.2 èƒŒæ™¯ç§»é™¤æŠ€æœ¯
**è½»é‡çº§å®ç°æ–¹æ¡ˆ**:
```javascript
class BackgroundRemover {
  constructor() {
    // ä½¿ç”¨BodyPixè¿›è¡Œäººä½“åˆ†å‰²
    this.segmenter = new BodyPixSegmenter();
  }

  async removeBackground(imageData, options = {}) {
    // 1. äººä½“/ç‰©ä½“åˆ†å‰²
    const segmentation = await this.segmenter.segment(imageData);

    // 2. ç”Ÿæˆè’™ç‰ˆ
    const mask = this.createMask(segmentation, options);

    // 3. åº”ç”¨è’™ç‰ˆ
    const result = await this.applyMask(imageData, mask);

    // 4. è¾¹ç¼˜ä¼˜åŒ–
    return this.refineEdges(result, options);
  }

  createMask(segmentation, options) {
    const { width, height } = segmentation;
    const mask = new ImageData(width, height);

    for (let i = 0; i < segmentation.data.length; i++) {
      const personScore = segmentation.data[i * 4]; // BodyPixè¾“å‡º
      const backgroundScore = 1 - personScore;

      // æ ¹æ®é˜ˆå€¼å†³å®šå‰æ™¯/èƒŒæ™¯
      const isForeground = personScore > (options.threshold || 0.7);
      mask.data[i * 4] = isForeground ? 255 : 0;     // R
      mask.data[i * 4 + 1] = isForeground ? 255 : 0; // G
      mask.data[i * 4 + 2] = isForeground ? 255 : 0; // B
      mask.data[i * 4 + 3] = 255;                     // A
    }

    return mask;
  }
}
```

### 5.5.4 éšç§ä¿æŠ¤æœºåˆ¶

#### 5.5.4.1 æ•°æ®éš”ç¦»è®¾è®¡
**è¯·æ±‚æ‹¦æˆªå’Œè¿‡æ»¤**:
```javascript
class PrivacyGuard {
  constructor() {
    this.allowedDomains = [
      'api.unsplash.com',
      'api.pexels.com',
      'pixabay.com'
    ];
    this.allowedHeaders = [
      'Authorization',
      'Accept-Version',
      'User-Agent'
    ];
  }

  interceptFetch(url, options) {
    // 1. éªŒè¯ç›®æ ‡åŸŸå
    if (!this.isAllowedDomain(url)) {
      throw new Error('Unauthorized external request');
    }

    // 2. è¿‡æ»¤è¯·æ±‚å¤´
    const cleanOptions = this.filterHeaders(options);

    // 3. è®°å½•è¯·æ±‚(ä»…ç”¨äºè°ƒè¯•)
    this.logRequest(url, cleanOptions);

    return [url, cleanOptions];
  }

  filterHeaders(options) {
    const cleanHeaders = {};

    for (const [key, value] of Object.entries(options.headers || {})) {
      if (this.allowedHeaders.includes(key)) {
        cleanHeaders[key] = value;
      }
    }

    return { ...options, headers: cleanHeaders };
  }

  isAllowedDomain(url) {
    try {
      const domain = new URL(url).hostname;
      return this.allowedDomains.some(allowed =>
        domain === allowed || domain.endsWith('.' + allowed)
      );
    } catch {
      return false;
    }
  }
}
```

#### 5.5.4.2 ç¼“å­˜å’Œæ¸…ç†ç­–ç•¥
```javascript
class CacheManager {
  constructor() {
    this.maxAge = 7 * 24 * 60 * 60 * 1000; // 7å¤©
    this.maxSize = 500 * 1024 * 1024; // 500MB
  }

  async store(key, data, metadata = {}) {
    const entry = {
      data,
      metadata,
      timestamp: Date.now(),
      accessCount: 0,
      lastAccessed: Date.now()
    };

    // æ£€æŸ¥å­˜å‚¨é…é¢
    if (await this.checkStorageQuota(entry)) {
      await this.evictOldEntries();
    }

    await this.storage.set(key, entry);
  }

  async retrieve(key) {
    const entry = await this.storage.get(key);
    if (!entry) return null;

    // æ›´æ–°è®¿é—®ç»Ÿè®¡
    entry.accessCount++;
    entry.lastAccessed = Date.now();
    await this.storage.set(key, entry);

    return entry.data;
  }

  async cleanup() {
    const now = Date.now();
    const keys = await this.storage.keys();

    for (const key of keys) {
      const entry = await this.storage.get(key);
      if (now - entry.timestamp > this.maxAge) {
        await this.storage.delete(key);
      }
    }
  }

  async checkStorageQuota(newEntry) {
    const usage = await this.getStorageUsage();
    const entrySize = this.calculateSize(newEntry);

    return usage + entrySize > this.maxSize;
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œç´ æç³»ç»Ÿæ˜¯ç”¨æˆ·ä½“éªŒçš„æ ¸å¿ƒï¼Œéšç§ä¿æŠ¤å’Œæ€§èƒ½ä¼˜åŒ–æ˜¯å…³é”®æŒ‘æˆ˜

---

## äº”ç‚¹å…­ã€ç”¨æˆ·è°ƒæ•´åŠŸèƒ½æŠ€æœ¯åˆ†æ

### 5.6.1 å¯è°ƒæ•´å†…å®¹èŒƒå›´è®¾è®¡

#### 5.6.1.1 è°ƒæ•´æƒé™åˆ†å±‚
**åŸºäºæ¨¡æ¿å±‚çº§çš„æƒé™æ§åˆ¶**:
```javascript
class AdjustmentPermissions {
  constructor() {
    this.permissions = {
      'fixed': {
        allowed: [],
        restricted: ['*']
      },
      'dynamic': {
        allowed: [],
        restricted: ['*']
      },
      'user-adjustable': {
        allowed: ['text', 'image', 'position', 'size', 'color'],
        restricted: ['animation', 'layout', 'structure']
      }
    };
  }

  canAdjust(layer, adjustmentType) {
    const layerType = layer.type;
    const layerPermissions = this.permissions[layerType];

    if (layerPermissions.allowed.includes(adjustmentType)) {
      return true;
    }

    if (layerPermissions.restricted.includes('*') ||
        layerPermissions.restricted.includes(adjustmentType)) {
      return false;
    }

    return false;
  }

  getAllowedAdjustments(layer) {
    const layerType = layer.type;
    return this.permissions[layerType].allowed;
  }
}
```

#### 5.6.1.2 æ–‡å­—å†…å®¹ç¼–è¾‘å™¨
**å¯Œæ–‡æœ¬ç¼–è¾‘ç»„ä»¶**:
```javascript
class TextEditor {
  constructor(container, options = {}) {
    this.container = container;
    this.options = {
      maxLength: options.maxLength || 100,
      allowedChars: options.allowedChars || /[\u4e00-\u9fa5a-zA-Z0-9\s]/,
      multiline: options.multiline || false,
      placeholder: options.placeholder || 'ç‚¹å‡»ç¼–è¾‘æ–‡å­—'
    };
    this.init();
  }

  init() {
    this.editor = document.createElement('div');
    this.editor.contentEditable = true;
    this.editor.className = 'text-editor';
    this.editor.innerHTML = this.options.placeholder;

    this.setupEventListeners();
    this.container.appendChild(this.editor);
  }

  setupEventListeners() {
    this.editor.addEventListener('input', this.onInput.bind(this));
    this.editor.addEventListener('blur', this.onBlur.bind(this));
    this.editor.addEventListener('keydown', this.onKeydown.bind(this));
  }

  onInput(event) {
    const text = this.getPlainText();
    const isValid = this.validateText(text);

    if (!isValid) {
      // æ¢å¤åˆ°ä¸Šä¸€ä¸ªæœ‰æ•ˆçŠ¶æ€
      this.restoreValidText();
      return;
    }

    // æ›´æ–°é¢„è§ˆ
    this.updatePreview(text);
  }

  validateText(text) {
    // é•¿åº¦éªŒè¯
    if (text.length > this.options.maxLength) {
      return false;
    }

    // å­—ç¬¦éªŒè¯
    if (!this.options.allowedChars.test(text)) {
      return false;
    }

    return true;
  }

  getPlainText() {
    return this.editor.textContent || this.editor.innerText || '';
  }

  updatePreview(text) {
    // é€šçŸ¥çˆ¶ç»„ä»¶æ›´æ–°é¢„è§ˆ
    this.emit('text-changed', {
      text,
      layerId: this.layerId
    });
  }
}
```

#### 5.6.1.3 ç´ æå›¾ç‰‡æ›¿æ¢å™¨
**æ‹–æ‹½ä¸Šä¼ å’Œé¢„è§ˆç»„ä»¶**:
```javascript
class ImageReplacer {
  constructor(layer, options = {}) {
    this.layer = layer;
    this.options = {
      maxSize: options.maxSize || 2 * 1024 * 1024, // 2MB
      allowedTypes: options.allowedTypes || ['image/jpeg', 'image/png'],
      previewSize: options.previewSize || { width: 200, height: 200 }
    };
    this.init();
  }

  init() {
    this.createDropZone();
    this.createFileInput();
    this.createPreview();
  }

  createDropZone() {
    this.dropZone = document.createElement('div');
    this.dropZone.className = 'image-drop-zone';
    this.dropZone.innerHTML = `
      <div class="drop-zone-content">
        <div class="icon">ğŸ“·</div>
        <div class="text">æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„æˆ–ç‚¹å‡»ä¸Šä¼ </div>
        <div class="hint">æ”¯æŒ JPGã€PNG æ ¼å¼ï¼Œæœ€å¤§ 2MB</div>
      </div>
    `;

    this.setupDropZoneEvents();
  }

  setupDropZoneEvents() {
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      this.dropZone.addEventListener(eventName, this.preventDefaults, false);
    });

    ['dragenter', 'dragover'].forEach(eventName => {
      this.dropZone.addEventListener(eventName, this.highlight.bind(this), false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
      this.dropZone.addEventListener(eventName, this.unhighlight.bind(this), false);
    });

    this.dropZone.addEventListener('drop', this.handleDrop.bind(this), false);
    this.dropZone.addEventListener('click', () => this.fileInput.click(), false);
  }

  async handleDrop(event) {
    const files = event.dataTransfer.files;
    await this.processFiles(files);
  }

  async processFiles(files) {
    for (const file of files) {
      if (this.validateFile(file)) {
        await this.uploadAndReplace(file);
      }
    }
  }

  validateFile(file) {
    // ç±»å‹éªŒè¯
    if (!this.options.allowedTypes.includes(file.type)) {
      this.showError('ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹');
      return false;
    }

    // å¤§å°éªŒè¯
    if (file.size > this.options.maxSize) {
      this.showError('æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶');
      return false;
    }

    return true;
  }

  async uploadAndReplace(file) {
    try {
      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      this.showLoading();

      // è¯»å–æ–‡ä»¶
      const imageData = await this.readFile(file);

      // éªŒè¯å›¾åƒ
      const validation = await this.validateImage(imageData);
      if (!validation.valid) {
        throw new Error(validation.error);
      }

      // æ›¿æ¢ç´ æ
      await this.replaceImage(imageData, file.name);

      // æ›´æ–°é¢„è§ˆ
      this.updatePreview(imageData);

      this.hideLoading();
      this.showSuccess('å›¾ç‰‡æ›¿æ¢æˆåŠŸ');

    } catch (error) {
      this.hideLoading();
      this.showError(error.message);
    }
  }

  async readFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  async validateImage(imageData) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        // æ£€æŸ¥å°ºå¯¸ã€æ¯”ä¾‹ç­‰
        const validation = {
          valid: img.width > 100 && img.height > 100,
          error: img.width <= 100 || img.height <= 100 ?
            'å›¾ç‰‡å°ºå¯¸å¤ªå°ï¼Œè¯·ä½¿ç”¨è‡³å°‘ 100x100 çš„å›¾ç‰‡' : null
        };
        resolve(validation);
      };
      img.onerror = () => resolve({ valid: false, error: 'æ— æ•ˆçš„å›¾ç‰‡æ–‡ä»¶' });
      img.src = imageData;
    });
  }

  async replaceImage(imageData, filename) {
    // æ›´æ–°å›¾å±‚æ•°æ®
    this.layer.imageData = imageData;
    this.layer.metadata = {
      filename,
      uploadedAt: Date.now(),
      source: 'user-upload'
    };

    // é€šçŸ¥æ¸²æŸ“å¼•æ“
    this.emit('image-replaced', {
      layerId: this.layer.id,
      imageData,
      metadata: this.layer.metadata
    });
  }
}
```

### 5.6.2 è°ƒæ•´ç•Œé¢è®¾è®¡

#### 5.6.2.1 å±æ€§é¢æ¿æ¶æ„
**å“åº”å¼å±æ€§ç¼–è¾‘å™¨**:
```javascript
class PropertyPanel {
  constructor(layer, container) {
    this.layer = layer;
    this.container = container;
    this.editors = {};
    this.init();
  }

  init() {
    this.createPanelStructure();
    this.createEditors();
    this.setupEventListeners();
  }

  createPanelStructure() {
    this.panel = document.createElement('div');
    this.panel.className = 'property-panel';
    this.panel.innerHTML = `
      <div class="panel-header">
        <h3>${this.layer.name} è®¾ç½®</h3>
      </div>
      <div class="panel-content">
        <div class="property-groups">
          <!-- åŠ¨æ€ç”Ÿæˆçš„å±æ€§ç»„ -->
        </div>
      </div>
    `;
    this.container.appendChild(this.panel);
  }

  createEditors() {
    const permissions = new AdjustmentPermissions();
    const allowedAdjustments = permissions.getAllowedAdjustments(this.layer);

    for (const adjustmentType of allowedAdjustments) {
      this.createEditorForType(adjustmentType);
    }
  }

  createEditorForType(type) {
    const group = document.createElement('div');
    group.className = `property-group property-${type}`;

    switch (type) {
      case 'text':
        group.innerHTML = `
          <label class="property-label">æ–‡å­—å†…å®¹</label>
          <div class="text-editor-container"></div>
        `;
        this.editors.text = new TextEditor(group.querySelector('.text-editor-container'), {
          maxLength: 20,
          placeholder: 'è¾“å…¥æ–‡å­—å†…å®¹'
        });
        break;

      case 'position':
        group.innerHTML = `
          <label class="property-label">ä½ç½®</label>
          <div class="position-selector">
            <button class="pos-btn" data-pos="top-left">â†–</button>
            <button class="pos-btn" data-pos="top-right">â†—</button>
            <button class="pos-btn" data-pos="bottom-left">â†™</button>
            <button class="pos-btn" data-pos="bottom-right">â†˜</button>
          </div>
        `;
        this.setupPositionSelector(group);
        break;

      case 'size':
        group.innerHTML = `
          <label class="property-label">å¤§å°: <span class="size-value">25%</span></label>
          <input type="range" class="size-slider" min="10" max="50" value="25">
        `;
        this.setupSizeSlider(group);
        break;

      case 'color':
        group.innerHTML = `
          <label class="property-label">é¢œè‰²</label>
          <div class="color-palette">
            <div class="color-option" data-color="#FFD700" style="background: #FFD700"></div>
            <div class="color-option" data-color="#FFFFFF" style="background: #FFFFFF"></div>
            <div class="color-option" data-color="#000000" style="background: #000000"></div>
            <div class="color-option" data-color="#FF6B6B" style="background: #FF6B6B"></div>
            <input type="color" class="color-picker">
          </div>
        `;
        this.setupColorSelector(group);
        break;

      case 'image':
        group.innerHTML = `
          <label class="property-label">ç´ æå›¾ç‰‡</label>
          <div class="image-replacer-container"></div>
          <button class="replace-btn">æ›¿æ¢å›¾ç‰‡</button>
        `;
        this.editors.image = new ImageReplacer(this.layer, group.querySelector('.image-replacer-container'));
        break;
    }

    this.panel.querySelector('.property-groups').appendChild(group);
  }

  setupPositionSelector(group) {
    const buttons = group.querySelectorAll('.pos-btn');
    buttons.forEach(btn => {
      btn.addEventListener('click', () => {
        buttons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        this.updateLayerProperty('position', btn.dataset.pos);
      });
    });
  }

  setupSizeSlider(group) {
    const slider = group.querySelector('.size-slider');
    const valueDisplay = group.querySelector('.size-value');

    slider.addEventListener('input', () => {
      const value = slider.value;
      valueDisplay.textContent = `${value}%`;
      this.updateLayerProperty('size', parseInt(value) / 100);
    });
  }

  setupColorSelector(group) {
    const options = group.querySelectorAll('.color-option');
    const picker = group.querySelector('.color-picker');

    options.forEach(option => {
      option.addEventListener('click', () => {
        this.updateLayerProperty('color', option.dataset.color);
        options.forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
      });
    });

    picker.addEventListener('change', () => {
      this.updateLayerProperty('color', picker.value);
    });
  }

  updateLayerProperty(property, value) {
    // æ›´æ–°å›¾å±‚å±æ€§
    this.layer.properties[property] = value;

    // é€šçŸ¥æ¸²æŸ“å¼•æ“é‡æ–°æ¸²æŸ“
    this.emit('property-changed', {
      layerId: this.layer.id,
      property,
      value
    });
  }
}
```

#### 5.6.2.2 å®æ—¶é¢„è§ˆç³»ç»Ÿ
**å¢é‡æ›´æ–°æ¸²æŸ“**:
```javascript
class LivePreview {
  constructor(canvas, layers) {
    this.canvas = canvas;
    this.layers = layers;
    this.debouncedUpdate = this.debounce(this.updatePreview.bind(this), 100);
  }

  onPropertyChange(change) {
    // åº”ç”¨å±æ€§å˜æ›´
    this.applyChange(change);

    // é˜²æŠ–æ›´æ–°é¢„è§ˆ
    this.debouncedUpdate();
  }

  applyChange(change) {
    const { layerId, property, value } = change;
    const layer = this.layers.find(l => l.id === layerId);

    if (layer) {
      layer.properties[property] = value;

      // æ ‡è®°ä¸ºå·²ä¿®æ”¹
      layer.modified = true;
      layer.modifiedAt = Date.now();
    }
  }

  async updatePreview() {
    // åªé‡æ–°æ¸²æŸ“ä¿®æ”¹è¿‡çš„å›¾å±‚
    const modifiedLayers = this.layers.filter(l => l.modified);

    if (modifiedLayers.length === 0) return;

    // å¢é‡æ¸²æŸ“ä¼˜åŒ–
    await this.renderIncremental(modifiedLayers);

    // é‡ç½®ä¿®æ”¹æ ‡è®°
    modifiedLayers.forEach(l => l.modified = false);
  }

  async renderIncremental(modifiedLayers) {
    const ctx = this.canvas.getContext('2d');

    for (const layer of modifiedLayers) {
      // åªæ¸²æŸ“å•ä¸ªå›¾å±‚
      await this.renderLayer(ctx, layer);
    }
  }

  debounce(func, delay) {
    let timeoutId;
    return function (...args) {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func.apply(this, args), delay);
    };
  }
}
```

### 5.6.3 ä¿æŠ¤æœºåˆ¶å®ç°

#### 5.6.3.1 çº¦æŸéªŒè¯ç³»ç»Ÿ
**å®æ—¶çº¦æŸæ£€æŸ¥**:
```javascript
class ConstraintValidator {
  constructor(constraints) {
    this.constraints = constraints;
    this.validators = {
      size: this.validateSize.bind(this),
      position: this.validatePosition.bind(this),
      text: this.validateText.bind(this),
      color: this.validateColor.bind(this)
    };
  }

  validate(layerId, property, value) {
    const constraint = this.constraints[layerId]?.[property];
    if (!constraint) return { valid: true };

    const validator = this.validators[property];
    if (validator) {
      return validator(value, constraint);
    }

    return { valid: true };
  }

  validateSize(value, constraint) {
    const { min, max } = constraint;
    if (value < min || value > max) {
      return {
        valid: false,
        error: `å°ºå¯¸å¿…é¡»åœ¨ ${min * 100}% - ${max * 100}% ä¹‹é—´`,
        suggestion: value < min ? min : max
      };
    }
    return { valid: true };
  }

  validatePosition(value, constraint) {
    if (!constraint.allowed.includes(value)) {
      return {
        valid: false,
        error: 'ä¸æ”¯æŒçš„ä½ç½®',
        suggestion: constraint.allowed[0]
      };
    }
    return { valid: true };
  }

  validateText(value, constraint) {
    if (value.length > constraint.maxLength) {
      return {
        valid: false,
        error: `æ–‡å­—é•¿åº¦ä¸èƒ½è¶…è¿‡ ${constraint.maxLength} ä¸ªå­—ç¬¦`,
        suggestion: value.substring(0, constraint.maxLength)
      };
    }

    if (constraint.allowedChars && !constraint.allowedChars.test(value)) {
      return {
        valid: false,
        error: 'åŒ…å«ä¸æ”¯æŒçš„å­—ç¬¦',
        suggestion: value.replace(new RegExp(`[^${constraint.allowedChars.source}]`, 'g'), '')
      };
    }

    return { valid: true };
  }
}
```

#### 5.6.3.2 æ™ºèƒ½å»ºè®®ç³»ç»Ÿ
**åŸºäºçº¦æŸçš„å»ºè®®ç”Ÿæˆ**:
```javascript
class SmartSuggestions {
  constructor(validator) {
    this.validator = validator;
  }

  generateSuggestions(layerId, property, invalidValue) {
    const constraint = this.validator.constraints[layerId]?.[property];
    if (!constraint) return [];

    const suggestions = [];

    switch (property) {
      case 'size':
        suggestions.push({
          value: constraint.min,
          label: `æœ€å°å°ºå¯¸ (${constraint.min * 100}%)`,
          reason: 'ä¿æŒå†…å®¹å¯è§æ€§'
        });
        suggestions.push({
          value: (constraint.min + constraint.max) / 2,
          label: `æ¨èå°ºå¯¸ (${((constraint.min + constraint.max) / 2 * 100).toFixed(0)}%)`,
          reason: 'æœ€ä½³è§†è§‰å¹³è¡¡'
        });
        suggestions.push({
          value: constraint.max,
          label: `æœ€å¤§å°ºå¯¸ (${constraint.max * 100}%)`,
          reason: 'æœ€å¤§åŒ–è§†è§‰å†²å‡»'
        });
        break;

      case 'position':
        constraint.allowed.forEach(pos => {
          suggestions.push({
            value: pos,
            label: this.getPositionLabel(pos),
            reason: this.getPositionReason(pos)
          });
        });
        break;

      case 'text':
        if (invalidValue.length > constraint.maxLength) {
          suggestions.push({
            value: invalidValue.substring(0, constraint.maxLength),
            label: `æˆªå–å‰ ${constraint.maxLength} ä¸ªå­—ç¬¦`,
            reason: 'ä¿æŒæ–‡å­—å®Œæ•´æ€§'
          });
        }
        break;
    }

    return suggestions;
  }

  getPositionLabel(position) {
    const labels = {
      'top-left': 'å·¦ä¸Šè§’',
      'top-right': 'å³ä¸Šè§’',
      'bottom-left': 'å·¦ä¸‹è§’',
      'bottom-right': 'å³ä¸‹è§’'
    };
    return labels[position] || position;
  }

  getPositionReason(position) {
    const reasons = {
      'top-left': 'ä¼ ç»Ÿé˜…è¯»ä¹ æƒ¯',
      'top-right': 'ç”»ä¸­ç”»å¸¸ç”¨ä½ç½®',
      'bottom-left': 'é¿å…é®æŒ¡ä¸»è¦å†…å®¹',
      'bottom-right': 'æœ€ä½³è§†è§‰å¹³è¡¡'
    };
    return reasons[position] || 'ç¬¦åˆè®¾è®¡è§„èŒƒ';
  }
}
```

#### 5.6.3.3 ä¸€é”®æ¢å¤æœºåˆ¶
**çŠ¶æ€å¿«ç…§å’Œæ¢å¤**:
```javascript
class StateManager {
  constructor() {
    this.snapshots = [];
    this.currentIndex = -1;
    this.maxSnapshots = 10;
  }

  takeSnapshot(state) {
    // ç§»é™¤å½“å‰ç´¢å¼•ä¹‹åçš„å†å²è®°å½•
    this.snapshots = this.snapshots.slice(0, this.currentIndex + 1);

    // æ·»åŠ æ–°å¿«ç…§
    const snapshot = {
      data: JSON.parse(JSON.stringify(state)), // æ·±æ‹·è´
      timestamp: Date.now(),
      description: this.generateDescription(state)
    };

    this.snapshots.push(snapshot);
    this.currentIndex = this.snapshots.length - 1;

    // é™åˆ¶å¿«ç…§æ•°é‡
    if (this.snapshots.length > this.maxSnapshots) {
      this.snapshots.shift();
      this.currentIndex--;
    }
  }

  canUndo() {
    return this.currentIndex > 0;
  }

  canRedo() {
    return this.currentIndex < this.snapshots.length - 1;
  }

  undo() {
    if (!this.canUndo()) return null;

    this.currentIndex--;
    return this.snapshots[this.currentIndex].data;
  }

  redo() {
    if (!this.canRedo()) return null;

    this.currentIndex++;
    return this.snapshots[this.currentIndex].data;
  }

  restoreToDefault(template) {
    // ä»æ¨¡æ¿åˆ›å»ºé»˜è®¤çŠ¶æ€
    const defaultState = this.createDefaultState(template);
    this.takeSnapshot(defaultState);
    return defaultState;
  }

  createDefaultState(template) {
    // æ ¹æ®æ¨¡æ¿å®šä¹‰åˆ›å»ºé»˜è®¤çŠ¶æ€
    const defaultState = {
      layers: template.layers.map(layer => ({
        id: layer.id,
        type: layer.type,
        properties: { ...layer.properties },
        modified: false
      }))
    };
    return defaultState;
  }

  generateDescription(state) {
    const modifiedLayers = state.layers.filter(l => l.modified);
    if (modifiedLayers.length === 0) return 'åˆå§‹çŠ¶æ€';

    const descriptions = modifiedLayers.map(layer => {
      const changes = Object.keys(layer.properties).length;
      return `${layer.name}(${changes}å¤„ä¿®æ”¹)`;
    });

    return descriptions.join(', ');
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œç”¨æˆ·è°ƒæ•´åŠŸèƒ½æ˜¯æå‡ç”¨æˆ·ä½“éªŒçš„å…³é”®ï¼Œçº¦æŸç³»ç»Ÿç¡®ä¿ä¸“ä¸šæ€§

---

## äº”ç‚¹ä¸ƒã€åŠ¨æ€æ•ˆæœç”ŸæˆæŠ€æœ¯åˆ†æ

### 5.7.1 æ–‡å­—åŠ¨ç”»ç³»ç»Ÿ

#### 5.7.1.1 åŠ¨ç”»å¼•æ“æ¶æ„
**åŸºäºæ—¶é—´è½´çš„åŠ¨ç”»è°ƒåº¦å™¨**:
```javascript
class AnimationEngine {
  constructor(canvas) {
    this.canvas = canvas;
    this.animations = new Map();
    this.isRunning = false;
    this.currentTime = 0;
    this.frameRate = 60;
    this.frameInterval = 1000 / this.frameRate;
  }

  start() {
    if (this.isRunning) return;
    this.isRunning = true;
    this.lastFrameTime = performance.now();
    this.animate();
  }

  stop() {
    this.isRunning = false;
  }

  animate() {
    if (!this.isRunning) return;

    const now = performance.now();
    const deltaTime = now - this.lastFrameTime;

    if (deltaTime >= this.frameInterval) {
      this.currentTime += deltaTime;
      this.lastFrameTime = now;

      this.updateAnimations(deltaTime);
      this.render();
    }

    requestAnimationFrame(this.animate.bind(this));
  }

  addAnimation(animation) {
    this.animations.set(animation.id, animation);
    animation.startTime = this.currentTime;
  }

  removeAnimation(id) {
    this.animations.delete(id);
  }

  updateAnimations(deltaTime) {
    for (const [id, animation] of this.animations) {
      const elapsed = this.currentTime - animation.startTime;

      if (elapsed >= animation.duration) {
        // åŠ¨ç”»ç»“æŸ
        animation.onComplete?.();
        this.removeAnimation(id);
      } else {
        // æ›´æ–°åŠ¨ç”»çŠ¶æ€
        const progress = elapsed / animation.duration;
        const easedProgress = animation.easing(progress);

        animation.update(easedProgress);
      }
    }
  }

  render() {
    const ctx = this.canvas.getContext('2d');
    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // æ¸²æŸ“æ‰€æœ‰æ´»åŠ¨åŠ¨ç”»
    for (const animation of this.animations.values()) {
      animation.render(ctx);
    }
  }
}
```

#### 5.7.1.2 æ–‡å­—åŠ¨ç”»ç±»å‹
**å…³é”®è¯å¼ºè°ƒåŠ¨ç”»**:
```javascript
class TextHighlightAnimation {
  constructor(textElement, options = {}) {
    this.textElement = textElement;
    this.duration = options.duration || 800;
    this.easing = options.easing || easeOutCubic;

    // åŠ¨ç”»å±æ€§
    this.startColor = options.startColor || '#FFFFFF';
    this.endColor = options.endColor || '#FFD700';
    this.startScale = options.startScale || 1.0;
    this.endScale = options.endScale || 1.2;
    this.startShadow = options.startShadow || '0px 0px 0px rgba(255,215,0,0)';
    this.endShadow = options.endShadow || '0px 0px 10px rgba(255,215,0,0.8)';
  }

  update(progress) {
    // é¢œè‰²æ’å€¼
    const color = this.interpolateColor(this.startColor, this.endColor, progress);

    // ç¼©æ”¾æ’å€¼
    const scale = this.startScale + (this.endScale - this.startScale) * progress;

    // é˜´å½±æ’å€¼
    const shadow = this.interpolateShadow(this.startShadow, this.endShadow, progress);

    // åº”ç”¨å˜æ¢
    this.applyTransform(color, scale, shadow);
  }

  interpolateColor(color1, color2, factor) {
    const c1 = this.hexToRgb(color1);
    const c2 = this.hexToRgb(color2);

    const r = Math.round(c1.r + (c2.r - c1.r) * factor);
    const g = Math.round(c1.g + (c2.g - c1.g) * factor);
    const b = Math.round(c1.b + (c2.b - c1.b) * factor);

    return `rgb(${r}, ${g}, ${b})`;
  }

  interpolateShadow(shadow1, shadow2, factor) {
    // ç®€åŒ–çš„é˜´å½±æ’å€¼
    const shadows = [shadow1, shadow2];
    return factor < 0.5 ? shadows[0] : shadows[1];
  }

  applyTransform(color, scale, shadow) {
    this.textElement.style.color = color;
    this.textElement.style.transform = `scale(${scale})`;
    this.textElement.style.textShadow = shadow;
  }

  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }
}
```

**æ•°æ®æ»šåŠ¨åŠ¨ç”»**:
```javascript
class NumberScrollAnimation {
  constructor(numberElement, targetValue, options = {}) {
    this.element = numberElement;
    this.startValue = options.startValue || 0;
    this.targetValue = targetValue;
    this.duration = options.duration || 1500;
    this.easing = options.easing || easeOutCubic;
    this.format = options.format || ((n) => n.toFixed(0));

    this.currentValue = this.startValue;
  }

  update(progress) {
    const easedProgress = this.easing(progress);
    this.currentValue = this.startValue +
      (this.targetValue - this.startValue) * easedProgress;

    this.element.textContent = this.format(this.currentValue);
  }
}
```

**æ ‡é¢˜æ¸å…¥åŠ¨ç”»**:
```javascript
class TitleFadeInAnimation {
  constructor(titleElement, options = {}) {
    this.element = titleElement;
    this.duration = options.duration || 1000;
    this.direction = options.direction || 'up'; // 'up', 'down', 'left', 'right'
    this.distance = options.distance || 50;

    this.startOpacity = 0;
    this.endOpacity = 1;
    this.startTransform = this.getStartTransform();
    this.endTransform = 'translate(0, 0) scale(1)';
  }

  getStartTransform() {
    switch (this.direction) {
      case 'up': return `translate(0, ${this.distance}px) scale(0.8)`;
      case 'down': return `translate(0, -${this.distance}px) scale(0.8)`;
      case 'left': return `translate(${this.distance}px, 0) scale(0.8)`;
      case 'right': return `translate(-${this.distance}px, 0) scale(0.8)`;
      default: return 'translate(0, 0) scale(1)';
    }
  }

  update(progress) {
    const easedProgress = this.easing?.(progress) || progress;

    const opacity = this.startOpacity +
      (this.endOpacity - this.startOpacity) * easedProgress;

    const transform = this.interpolateTransform(easedProgress);

    this.element.style.opacity = opacity;
    this.element.style.transform = transform;
  }

  interpolateTransform(progress) {
    // ç®€åŒ–çš„å˜æ¢æ’å€¼
    const start = this.parseTransform(this.startTransform);
    const end = this.parseTransform(this.endTransform);

    const translateX = start.translateX + (end.translateX - start.translateX) * progress;
    const translateY = start.translateY + (end.translateY - start.translateY) * progress;
    const scale = start.scale + (end.scale - start.scale) * progress;

    return `translate(${translateX}px, ${translateY}px) scale(${scale})`;
  }

  parseTransform(transform) {
    const translateMatch = transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    const scaleMatch = transform.match(/scale\(([^)]+)\)/);

    return {
      translateX: translateMatch ? parseFloat(translateMatch[1]) : 0,
      translateY: translateMatch ? parseFloat(translateMatch[2]) : 0,
      scale: scaleMatch ? parseFloat(scaleMatch[1]) : 1
    };
  }
}
```

### 5.7.2 ç”»ä¸­ç”»åŠ¨ç”»ç³»ç»Ÿ

#### 5.7.2.1 å…¥åœºå’Œé€€å‡ºåŠ¨ç”»
**ç¼©æ”¾æ·¡å…¥æ•ˆæœ**:
```javascript
class PIPEntranceAnimation {
  constructor(pipElement, options = {}) {
    this.element = pipElement;
    this.duration = options.duration || 300;
    this.easing = options.easing || easeOutBack;

    this.startScale = 0.8;
    this.endScale = 1.0;
    this.startOpacity = 0;
    this.endOpacity = 1;
  }

  async animate() {
    return new Promise(resolve => {
      const startTime = performance.now();

      const animate = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / this.duration, 1);

        const easedProgress = this.easing(progress);

        const scale = this.startScale + (this.endScale - this.startScale) * easedProgress;
        const opacity = this.startOpacity + (this.endOpacity - this.endOpacity) * easedProgress;

        this.element.style.transform = `scale(${scale})`;
        this.element.style.opacity = opacity;

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };

      requestAnimationFrame(animate);
    });
  }
}
```

**è·ŸéšåŠ¨ç”»**:
```javascript
class PIPFollowAnimation {
  constructor(pipElement, faceTracker) {
    this.element = pipElement;
    this.tracker = faceTracker;
    this.smoothing = 0.1; // å¹³æ»‘ç³»æ•°
    this.currentPosition = { x: 0, y: 0 };
    this.targetPosition = { x: 0, y: 0 };
    this.isAnimating = false;
  }

  start() {
    if (this.isAnimating) return;
    this.isAnimating = true;
    this.animate();
  }

  stop() {
    this.isAnimating = false;
  }

  updateTarget(facePosition) {
    // è½¬æ¢äººè„¸ä½ç½®åˆ°ç”»ä¸­ç”»ä½ç½®
    this.targetPosition = this.convertFaceToPIP(facePosition);
  }

  convertFaceToPIP(facePosition) {
    // ç¡®ä¿ç”»ä¸­ç”»å§‹ç»ˆè·Ÿéšäººè„¸ï¼Œä½†ä¿æŒåœ¨åˆç†è¾¹ç•Œå†…
    const pipRect = this.element.getBoundingClientRect();
    const containerRect = this.element.parentElement.getBoundingClientRect();

    let x = facePosition.x - pipRect.width / 2;
    let y = facePosition.y - pipRect.height / 2;

    // è¾¹ç•Œæ£€æŸ¥
    x = Math.max(0, Math.min(x, containerRect.width - pipRect.width));
    y = Math.max(0, Math.min(y, containerRect.height - pipRect.height));

    return { x, y };
  }

  animate() {
    if (!this.isAnimating) return;

    // å¹³æ»‘æ’å€¼
    this.currentPosition.x += (this.targetPosition.x - this.currentPosition.x) * this.smoothing;
    this.currentPosition.y += (this.targetPosition.y - this.currentPosition.y) * this.smoothing;

    // åº”ç”¨ä½ç½®
    this.element.style.transform = `translate(${this.currentPosition.x}px, ${this.currentPosition.y}px)`;

    requestAnimationFrame(this.animate.bind(this));
  }
}
```

#### 5.7.2.2 è¾¹ç¼˜ä¿æŠ¤åŠ¨ç”»
**æ™ºèƒ½ä½ç½®è°ƒæ•´**:
```javascript
class EdgeProtectionAnimation {
  constructor(pipElement, boundaries) {
    this.element = pipElement;
    this.boundaries = boundaries; // { top, right, bottom, left }
    this.adjustmentThreshold = 50; // åƒç´ é˜ˆå€¼
    this.adjustmentDuration = 200;
  }

  checkAndAdjust(facePosition) {
    const pipRect = this.element.getBoundingClientRect();
    const violations = this.detectBoundaryViolations(pipRect);

    if (violations.length > 0) {
      return this.animateToSafePosition(violations);
    }

    return Promise.resolve();
  }

  detectBoundaryViolations(pipRect) {
    const violations = [];

    if (pipRect.left < this.boundaries.left + this.adjustmentThreshold) {
      violations.push('left');
    }
    if (pipRect.right > this.boundaries.right - this.adjustmentThreshold) {
      violations.push('right');
    }
    if (pipRect.top < this.boundaries.top + this.adjustmentThreshold) {
      violations.push('top');
    }
    if (pipRect.bottom > this.boundaries.bottom - this.adjustmentThreshold) {
      violations.push('bottom');
    }

    return violations;
  }

  animateToSafePosition(violations) {
    return new Promise(resolve => {
      const startTime = performance.now();
      const startPosition = this.getCurrentPosition();
      const safePosition = this.calculateSafePosition(startPosition, violations);

      const animate = (currentTime) => {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / this.adjustmentDuration, 1);

        const easedProgress = easeOutQuad(progress);

        const currentX = startPosition.x +
          (safePosition.x - startPosition.x) * easedProgress;
        const currentY = startPosition.y +
          (safePosition.y - startPosition.y) * easedProgress;

        this.element.style.transform = `translate(${currentX}px, ${currentY}px)`;

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };

      requestAnimationFrame(animate);
    });
  }

  getCurrentPosition() {
    const transform = getComputedStyle(this.element).transform;
    if (transform === 'none') return { x: 0, y: 0 };

    const matrix = new DOMMatrix(transform);
    return { x: matrix.m41, y: matrix.m42 };
  }

  calculateSafePosition(currentPosition, violations) {
    let x = currentPosition.x;
    let y = currentPosition.y;

    violations.forEach(violation => {
      switch (violation) {
        case 'left':
          x = this.boundaries.left + 10;
          break;
        case 'right':
          x = this.boundaries.right - this.element.offsetWidth - 10;
          break;
        case 'top':
          y = this.boundaries.top + 10;
          break;
        case 'bottom':
          y = this.boundaries.bottom - this.element.offsetHeight - 10;
          break;
      }
    });

    return { x, y };
  }
}
```

### 5.7.3 æ—¶åºåŒæ­¥ç³»ç»Ÿ

#### 5.7.3.1 è¯­éŸ³-åŠ¨ç”»åŒæ­¥
**æ—¶é—´è½´ç®¡ç†å™¨**:
```javascript
class TimelineSynchronizer {
  constructor(audioElement, animationEngine) {
    this.audio = audioElement;
    this.animationEngine = animationEngine;
    this.markers = []; // æ—¶é—´æ ‡è®°ç‚¹
    this.listeners = new Map();
  }

  addMarker(time, type, data) {
    this.markers.push({
      time,
      type,
      data,
      id: generateId()
    });

    // æŒ‰æ—¶é—´æ’åº
    this.markers.sort((a, b) => a.time - b.time);
  }

  startSync() {
    this.audio.addEventListener('timeupdate', this.onTimeUpdate.bind(this));
    this.checkMarkers();
  }

  stopSync() {
    this.audio.removeEventListener('timeupdate', this.onTimeUpdate);
  }

  onTimeUpdate() {
    const currentTime = this.audio.currentTime;
    this.checkMarkers(currentTime);
  }

  checkMarkers(currentTime) {
    // æ£€æŸ¥æ˜¯å¦æœ‰éœ€è¦è§¦å‘çš„æ ‡è®°ç‚¹
    const triggeredMarkers = this.markers.filter(marker =>
      !marker.triggered &&
      currentTime >= marker.time &&
      currentTime < marker.time + 0.1 // 100mså®¹å·®
    );

    triggeredMarkers.forEach(marker => {
      this.triggerMarker(marker);
      marker.triggered = true;
    });
  }

  triggerMarker(marker) {
    switch (marker.type) {
      case 'text-highlight':
        this.triggerTextHighlight(marker.data);
        break;
      case 'number-scroll':
        this.triggerNumberScroll(marker.data);
        break;
      case 'pip-enter':
        this.triggerPIPEntrance(marker.data);
        break;
      case 'pip-exit':
        this.triggerPIPExit(marker.data);
        break;
    }

    // é€šçŸ¥ç›‘å¬å™¨
    this.notifyListeners(marker.type, marker);
  }

  triggerTextHighlight(data) {
    const animation = new TextHighlightAnimation(data.element, data.options);
    this.animationEngine.addAnimation(animation);
  }

  triggerNumberScroll(data) {
    const animation = new NumberScrollAnimation(data.element, data.targetValue, data.options);
    this.animationEngine.addAnimation(animation);
  }

  triggerPIPEntrance(data) {
    const animation = new PIPEntranceAnimation(data.element, data.options);
    this.animationEngine.addAnimation(animation);
  }

  triggerPIPExit(data) {
    const animation = new PIPExitAnimation(data.element, data.options);
    this.animationEngine.addAnimation(animation);
  }

  on(eventType, callback) {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    this.listeners.get(eventType).push(callback);
  }

  notifyListeners(eventType, data) {
    const callbacks = this.listeners.get(eventType) || [];
    callbacks.forEach(callback => callback(data));
  }
}
```

#### 5.7.3.2 å®¹å·®å¤„ç†
**æ—¶é—´åŒæ­¥å®¹å·®ç®—æ³•**:
```javascript
class TimeToleranceHandler {
  constructor(tolerance = 100) { // 100msé»˜è®¤å®¹å·®
    this.tolerance = tolerance;
    this.pendingTriggers = new Map();
  }

  scheduleTrigger(time, callback, tolerance = null) {
    const actualTolerance = tolerance || this.tolerance;
    const triggerId = generateId();

    this.pendingTriggers.set(triggerId, {
      scheduledTime: time,
      callback,
      tolerance: actualTolerance,
      createdAt: performance.now()
    });

    return triggerId;
  }

  checkTriggers(currentTime) {
    const now = performance.now();

    for (const [id, trigger] of this.pendingTriggers) {
      const timeDiff = Math.abs(currentTime - trigger.scheduledTime);

      if (timeDiff <= trigger.tolerance) {
        // åœ¨å®¹å·®èŒƒå›´å†…ï¼Œæ‰§è¡Œè§¦å‘
        trigger.callback();
        this.pendingTriggers.delete(id);
      } else if (currentTime > trigger.scheduledTime + trigger.tolerance) {
        // è¶…å‡ºå®¹å·®èŒƒå›´ï¼Œå–æ¶ˆè§¦å‘
        console.warn(`Trigger missed: scheduled at ${trigger.scheduledTime}, current ${currentTime}`);
        this.pendingTriggers.delete(id);
      }
    }
  }

  clearTrigger(id) {
    this.pendingTriggers.delete(id);
  }

  clearAll() {
    this.pendingTriggers.clear();
  }
}
```

### 5.7.4 æ€§èƒ½ä¼˜åŒ–

#### 5.7.4.1 åŠ¨ç”»æ± ç®¡ç†
**å¯¹è±¡å¤ç”¨ä¼˜åŒ–**:
```javascript
class AnimationPool {
  constructor(maxSize = 20) {
    this.pool = [];
    this.maxSize = maxSize;
    this.available = [];
    this.inUse = new Set();
  }

  acquire(animationClass, ...args) {
    // å…ˆå°è¯•ä»å¯ç”¨æ± ä¸­è·å–
    let animation = this.available.pop();

    if (!animation) {
      // æ± ä¸ºç©ºï¼Œåˆ›å»ºæ–°å®ä¾‹
      if (this.pool.length < this.maxSize) {
        animation = new animationClass(...args);
        this.pool.push(animation);
      } else {
        // æ± å·²æ»¡ï¼Œç­‰å¾…æˆ–è¿”å›null
        return null;
      }
    }

    this.inUse.add(animation);
    return animation;
  }

  release(animation) {
    if (this.inUse.has(animation)) {
      this.inUse.delete(animation);
      this.available.push(animation);
    }
  }

  clear() {
    this.available.length = 0;
    this.inUse.clear();
  }

  getStats() {
    return {
      total: this.pool.length,
      available: this.available.length,
      inUse: this.inUse.size
    };
  }
}
```

#### 5.7.4.2 GPUåŠ é€Ÿä¼˜åŒ–
**WebGLæ¸²æŸ“ä¼˜åŒ–**:
```javascript
class WebGLAnimationRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.gl = canvas.getContext('webgl');
    this.program = null;
    this.buffers = {};
    this.textures = {};
  }

  initShaders() {
    const vertexShader = this.createShader(`
      attribute vec2 a_position;
      attribute vec2 a_texCoord;
      uniform mat3 u_matrix;
      varying vec2 v_texCoord;

      void main() {
        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
        v_texCoord = a_texCoord;
      }
    `, this.gl.VERTEX_SHADER);

    const fragmentShader = this.createShader(`
      precision mediump float;
      uniform sampler2D u_texture;
      uniform float u_opacity;
      varying vec2 v_texCoord;

      void main() {
        vec4 color = texture2D(u_texture, v_texCoord);
        gl_FragColor = vec4(color.rgb, color.a * u_opacity);
      }
    `, this.gl.FRAGMENT_SHADER);

    this.program = this.createProgram(vertexShader, fragmentShader);
  }

  renderAnimation(animation, time) {
    const progress = time / animation.duration;
    const transform = this.calculateTransform(animation, progress);

    this.gl.useProgram(this.program);
    this.setUniforms(transform, animation.opacity);

    // ç»‘å®šé¡¶ç‚¹ç¼“å†²
    this.bindBuffer(this.buffers.position, 'a_position');
    this.bindBuffer(this.buffers.texCoord, 'a_texCoord');

    // ç»‘å®šçº¹ç†
    this.bindTexture(animation.texture);

    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
  }

  calculateTransform(animation, progress) {
    // è®¡ç®—å˜æ¢çŸ©é˜µ
    const easedProgress = animation.easing(progress);

    const translateX = animation.startX + (animation.endX - animation.startX) * easedProgress;
    const translateY = animation.startY + (animation.endY - animation.startY) * easedProgress;
    const scale = animation.startScale + (animation.endScale - animation.startScale) * easedProgress;

    return [
      scale, 0, translateX,
      0, scale, translateY,
      0, 0, 1
    ];
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼ŒåŠ¨æ€æ•ˆæœæ˜¯æå‡æ¼”ç¤ºä¸“ä¸šåº¦çš„å…³é”®ï¼Œæ€§èƒ½ä¼˜åŒ–è‡³å…³é‡è¦

---

## äº”ç‚¹å…«ã€é¢„è§ˆä¸è°ƒæ•´åŠŸèƒ½æŠ€æœ¯åˆ†æ

### 5.8.1 å®æ—¶é¢„è§ˆç³»ç»Ÿ

#### 5.8.1.1 åˆ†å±‚é¢„è§ˆæ¶æ„
**å¤šåˆ†è¾¨ç‡é¢„è§ˆç­–ç•¥**:
```javascript
class PreviewSystem {
  constructor(container) {
    this.container = container;
    this.previewCanvas = null;
    this.thumbnailCanvas = null;
    this.fullResCanvas = null;

    this.currentQuality = 'medium'; // 'low', 'medium', 'high'
    this.isGenerating = false;
  }

  async init() {
    // åˆ›å»ºä¸åŒåˆ†è¾¨ç‡çš„é¢„è§ˆç”»å¸ƒ
    this.previewCanvas = this.createCanvas('preview', 800, 450);    // 16:9 é¢„è§ˆ
    this.thumbnailCanvas = this.createCanvas('thumbnail', 320, 180); // ç¼©ç•¥å›¾
    this.fullResCanvas = this.createCanvas('full', 1920, 1080);     // å…¨åˆ†è¾¨ç‡

    this.container.appendChild(this.previewCanvas);
  }

  createCanvas(id, width, height) {
    const canvas = document.createElement('canvas');
    canvas.id = id;
    canvas.width = width;
    canvas.height = height;
    canvas.style.display = 'none';
    return canvas;
  }

  async updatePreview(data, quality = 'medium') {
    if (this.isGenerating) {
      // å–æ¶ˆä¹‹å‰çš„é¢„è§ˆç”Ÿæˆ
      this.cancelCurrentPreview();
    }

    this.isGenerating = true;
    this.currentQuality = quality;

    try {
      // æ ¹æ®è´¨é‡é€‰æ‹©ç”»å¸ƒ
      const canvas = this.getCanvasForQuality(quality);
      const ctx = canvas.getContext('2d');

      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      this.showLoadingIndicator();

      // ç”Ÿæˆé¢„è§ˆ
      await this.generatePreview(ctx, data, quality);

      // æ˜¾ç¤ºé¢„è§ˆç»“æœ
      this.showPreview(canvas);

    } finally {
      this.isGenerating = false;
      this.hideLoadingIndicator();
    }
  }

  getCanvasForQuality(quality) {
    switch (quality) {
      case 'low': return this.thumbnailCanvas;
      case 'medium': return this.previewCanvas;
      case 'high': return this.fullResCanvas;
      default: return this.previewCanvas;
    }
  }

  async generatePreview(ctx, data, quality) {
    const { video, template, adjustments } = data;

    // 1. æ¸²æŸ“èƒŒæ™¯
    await this.renderBackground(ctx, template);

    // 2. æ¸²æŸ“è§†é¢‘å¸§ï¼ˆå¦‚æœæœ‰ï¼‰
    if (video) {
      await this.renderVideoFrame(ctx, video, quality);
    }

    // 3. æ¸²æŸ“æ¨¡æ¿å…ƒç´ 
    await this.renderTemplateElements(ctx, template, adjustments);

    // 4. åº”ç”¨åæœŸæ•ˆæœ
    await this.applyPostEffects(ctx, template);
  }

  async renderVideoFrame(ctx, video, quality) {
    const videoElement = document.createElement('video');
    videoElement.src = video.blobUrl;
    videoElement.currentTime = video.currentTime || 0;

    return new Promise(resolve => {
      videoElement.onloadeddata = () => {
        // æ ¹æ®è´¨é‡è°ƒæ•´è§†é¢‘å¤§å°
        const scale = this.getScaleForQuality(quality);
        const width = videoElement.videoWidth * scale;
        const height = videoElement.videoHeight * scale;

        ctx.drawImage(videoElement, 0, 0, width, height);
        resolve();
      };
    });
  }

  getScaleForQuality(quality) {
    const scales = {
      low: 0.25,
      medium: 0.5,
      high: 1.0
    };
    return scales[quality] || 0.5;
  }

  cancelCurrentPreview() {
    // å–æ¶ˆæ­£åœ¨è¿›è¡Œçš„é¢„è§ˆç”Ÿæˆ
    this.isGenerating = false;
  }

  showLoadingIndicator() {
    // æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
    this.loadingIndicator = document.createElement('div');
    this.loadingIndicator.className = 'preview-loading';
    this.loadingIndicator.innerHTML = `
      <div class="spinner"></div>
      <div class="text">ç”Ÿæˆé¢„è§ˆä¸­...</div>
    `;
    this.container.appendChild(this.loadingIndicator);
  }

  hideLoadingIndicator() {
    if (this.loadingIndicator) {
      this.container.removeChild(this.loadingIndicator);
      this.loadingIndicator = null;
    }
  }

  showPreview(canvas) {
    // éšè—å…¶ä»–ç”»å¸ƒ
    [this.previewCanvas, this.thumbnailCanvas, this.fullResCanvas]
      .forEach(c => c.style.display = 'none');

    // æ˜¾ç¤ºå½“å‰é¢„è§ˆ
    canvas.style.display = 'block';
  }
}
```

#### 5.8.1.2 æ¸è¿›å¼é¢„è§ˆç”Ÿæˆ
**ä¼˜å…ˆçº§é˜Ÿåˆ—ç®¡ç†**:
```javascript
class ProgressivePreview {
  constructor(previewSystem) {
    this.previewSystem = previewSystem;
    this.queue = [];
    this.isProcessing = false;
    this.priorities = {
      'critical': 0,    // å…³é”®æ›´æ–°ï¼ˆå¦‚æ–‡å­—å˜åŒ–ï¼‰
      'important': 1,   // é‡è¦æ›´æ–°ï¼ˆå¦‚ä½ç½®å˜åŒ–ï¼‰
      'normal': 2       // æ™®é€šæ›´æ–°ï¼ˆå¦‚é¢œè‰²å¾®è°ƒï¼‰
    };
  }

  enqueue(update, priority = 'normal') {
    const queueItem = {
      update,
      priority: this.priorities[priority],
      timestamp: Date.now(),
      id: generateId()
    };

    // æ’å…¥åˆ°åˆé€‚ä½ç½®
    const insertIndex = this.findInsertIndex(queueItem.priority);
    this.queue.splice(insertIndex, 0, queueItem);

    this.processQueue();
  }

  findInsertIndex(priority) {
    // æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¼˜å…ˆçº§ä½äºå½“å‰é¡¹ç›®çš„ç´¢å¼•
    for (let i = 0; i < this.queue.length; i++) {
      if (this.queue[i].priority > priority) {
        return i;
      }
    }
    return this.queue.length;
  }

  async processQueue() {
    if (this.isProcessing || this.queue.length === 0) return;

    this.isProcessing = true;

    while (this.queue.length > 0) {
      const item = this.queue.shift();

      // æ£€æŸ¥æ˜¯å¦å·²è¢«æ–°é¡¹ç›®è¦†ç›–
      if (this.isOutdated(item)) continue;

      try {
        // ç”Ÿæˆå¯¹åº”è´¨é‡çš„é¢„è§ˆ
        const quality = this.determineQuality(item);
        await this.previewSystem.updatePreview(item.update, quality);

        // çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¿‡äºé¢‘ç¹çš„æ›´æ–°
        await this.delay(100);

      } catch (error) {
        console.error('Preview generation failed:', error);
      }
    }

    this.isProcessing = false;
  }

  isOutdated(item) {
    // æ£€æŸ¥æ˜¯å¦æœ‰æ›´é«˜ä¼˜å…ˆçº§çš„ç›¸åŒç±»å‹æ›´æ–°
    return this.queue.some(queuedItem =>
      queuedItem.priority <= item.priority &&
      queuedItem.update.type === item.update.type &&
      queuedItem.timestamp > item.timestamp
    );
  }

  determineQuality(item) {
    // æ ¹æ®ä¼˜å…ˆçº§å’Œæ›´æ–°ç±»å‹ç¡®å®šé¢„è§ˆè´¨é‡
    if (item.priority === this.priorities.critical) {
      return 'medium'; // å…³é”®æ›´æ–°ç”¨ä¸­ç­‰è´¨é‡ï¼Œé€Ÿåº¦å¿«
    } else if (item.priority === this.priorities.important) {
      return 'low';    // é‡è¦æ›´æ–°ç”¨ä½è´¨é‡ï¼Œå¿«é€Ÿåé¦ˆ
    } else {
      return 'high';   // æ™®é€šæ›´æ–°ç”¨é«˜è´¨é‡ï¼Œæœ€ç»ˆæ•ˆæœ
    }
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  clear() {
    this.queue.length = 0;
  }
}
```

### 5.8.2 ç²¾ç»†è°ƒæ•´åŠŸèƒ½

#### 5.8.2.1 æ—¶é—´è½´ç¼–è¾‘å™¨
**å…³é”®å¸§ç®¡ç†**:
```javascript
class TimelineEditor {
  constructor(container, duration) {
    this.container = container;
    this.duration = duration;
    this.keyframes = new Map();
    this.selectedKeyframe = null;
    this.zoom = 1.0;
    this.scrollLeft = 0;

    this.init();
  }

  init() {
    this.timelineElement = document.createElement('div');
    this.timelineElement.className = 'timeline-editor';

    this.createTimelineHeader();
    this.createTimelineBody();
    this.createTimelineControls();

    this.container.appendChild(this.timelineElement);
    this.bindEvents();
  }

  createTimelineHeader() {
    this.header = document.createElement('div');
    this.header.className = 'timeline-header';

    // æ—¶é—´åˆ»åº¦
    const timeScale = document.createElement('div');
    timeScale.className = 'time-scale';

    for (let i = 0; i <= this.duration; i += 10) {
      const marker = document.createElement('div');
      marker.className = 'time-marker';
      marker.textContent = this.formatTime(i);
      marker.style.left = `${(i / this.duration) * 100}%`;
      timeScale.appendChild(marker);
    }

    this.header.appendChild(timeScale);
  }

  createTimelineBody() {
    this.body = document.createElement('div');
    this.body.className = 'timeline-body';

    // åˆ›å»ºè½¨é“
    this.tracks = {
      video: this.createTrack('video', '#4A90E2'),
      text: this.createTrack('text', '#7ED321'),
      effects: this.createTrack('effects', '#F5A623'),
      audio: this.createTrack('audio', '#D0021B')
    };

    Object.values(this.tracks).forEach(track => {
      this.body.appendChild(track.element);
    });
  }

  createTrack(name, color) {
    const trackElement = document.createElement('div');
    trackElement.className = 'timeline-track';
    trackElement.dataset.trackName = name;

    const trackHeader = document.createElement('div');
    trackHeader.className = 'track-header';
    trackHeader.textContent = name;
    trackHeader.style.backgroundColor = color;

    const trackContent = document.createElement('div');
    trackContent.className = 'track-content';

    trackElement.appendChild(trackHeader);
    trackElement.appendChild(trackContent);

    return {
      element: trackElement,
      content: trackContent,
      color
    };
  }

  createTimelineControls() {
    this.controls = document.createElement('div');
    this.controls.className = 'timeline-controls';

    this.controls.innerHTML = `
      <button class="control-btn" id="zoom-in">æ”¾å¤§</button>
      <button class="control-btn" id="zoom-out">ç¼©å°</button>
      <button class="control-btn" id="fit-to-view">é€‚åº”è§†å›¾</button>
      <input type="range" id="time-scrubber" min="0" max="${this.duration}" step="0.1">
      <span id="current-time">0.00s</span>
    `;

    this.container.appendChild(this.controls);
  }

  bindEvents() {
    // æ—¶é—´è½´ç‚¹å‡»
    this.body.addEventListener('click', this.onTimelineClick.bind(this));

    // å…³é”®å¸§æ‹–æ‹½
    this.body.addEventListener('mousedown', this.onKeyframeMouseDown.bind(this));

    // ç¼©æ”¾æ§åˆ¶
    document.getElementById('zoom-in').addEventListener('click', () => this.zoomIn());
    document.getElementById('zoom-out').addEventListener('click', () => this.zoomOut());

    // æ—¶é—´è°ƒèŠ‚å™¨
    const scrubber = document.getElementById('time-scrubber');
    scrubber.addEventListener('input', (e) => {
      const time = parseFloat(e.target.value);
      this.setCurrentTime(time);
    });
  }

  addKeyframe(trackName, time, data) {
    const track = this.tracks[trackName];
    if (!track) return null;

    const keyframeElement = document.createElement('div');
    keyframeElement.className = 'keyframe';
    keyframeElement.style.backgroundColor = track.color;
    keyframeElement.style.left = `${(time / this.duration) * 100}%`;
    keyframeElement.dataset.time = time;
    keyframeElement.dataset.track = trackName;

    // å·¥å…·æç¤º
    keyframeElement.title = `${trackName} @ ${this.formatTime(time)}`;

    track.content.appendChild(keyframeElement);

    const keyframe = {
      id: generateId(),
      track: trackName,
      time,
      data,
      element: keyframeElement
    };

    this.keyframes.set(keyframe.id, keyframe);
    return keyframe;
  }

  removeKeyframe(keyframeId) {
    const keyframe = this.keyframes.get(keyframeId);
    if (keyframe) {
      keyframe.element.remove();
      this.keyframes.delete(keyframeId);
    }
  }

  setCurrentTime(time) {
    // æ›´æ–°æ—¶é—´æŒ‡ç¤ºå™¨
    const indicator = document.querySelector('.time-indicator') ||
                     document.createElement('div');

    indicator.className = 'time-indicator';
    indicator.style.left = `${(time / this.duration) * 100}%`;

    if (!indicator.parentElement) {
      this.body.appendChild(indicator);
    }

    // æ›´æ–°æ˜¾ç¤º
    document.getElementById('current-time').textContent =
      this.formatTime(time);

    // è§¦å‘æ—¶é—´å˜åŒ–äº‹ä»¶
    this.emit('time-changed', time);
  }

  zoomIn() {
    this.zoom = Math.min(this.zoom * 1.5, 10);
    this.updateZoom();
  }

  zoomOut() {
    this.zoom = Math.max(this.zoom / 1.5, 0.1);
    this.updateZoom();
  }

  updateZoom() {
    this.body.style.transform = `scaleX(${this.zoom})`;
    this.emit('zoom-changed', this.zoom);
  }

  formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = (seconds % 60).toFixed(2);
    return `${mins}:${secs.padStart(5, '0')}`;
  }

  onTimelineClick(event) {
    const rect = this.body.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const percentage = x / rect.width;
    const time = percentage * this.duration;

    this.setCurrentTime(time);
  }

  onKeyframeMouseDown(event) {
    const keyframeElement = event.target.closest('.keyframe');
    if (!keyframeElement) return;

    event.preventDefault();

    const keyframeId = Object.keys(this.keyframes).find(id =>
      this.keyframes[id].element === keyframeElement
    );

    if (keyframeId) {
      this.startKeyframeDrag(keyframeId, event);
    }
  }

  startKeyframeDrag(keyframeId, startEvent) {
    const keyframe = this.keyframes.get(keyframeId);
    this.selectedKeyframe = keyframe;

    const startX = startEvent.clientX;
    const startTime = keyframe.time;

    const onMouseMove = (moveEvent) => {
      const deltaX = moveEvent.clientX - startX;
      const deltaTime = (deltaX / this.body.offsetWidth) * this.duration;
      const newTime = Math.max(0, Math.min(this.duration, startTime + deltaTime));

      this.moveKeyframe(keyframeId, newTime);
    };

    const onMouseUp = () => {
      document.removeEventListener('mousemove', onMouseMove);
      document.removeEventListener('mouseup', onMouseUp);
      this.selectedKeyframe = null;
      this.emit('keyframe-moved', { keyframeId, time: keyframe.time });
    };

    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
  }

  moveKeyframe(keyframeId, newTime) {
    const keyframe = this.keyframes.get(keyframeId);
    keyframe.time = newTime;
    keyframe.element.style.left = `${(newTime / this.duration) * 100}%`;
    keyframe.element.dataset.time = newTime;
  }
}
```

#### 5.8.2.2 è°ƒæ•´é¢æ¿é›†æˆ
**ä¸Šä¸‹æ–‡æ„ŸçŸ¥è°ƒæ•´**:
```javascript
class AdjustmentPanel {
  constructor(timelineEditor, previewSystem) {
    this.timeline = timelineEditor;
    this.preview = previewSystem;
    this.currentElement = null;
    this.adjustments = {};

    this.init();
  }

  init() {
    this.panel = document.createElement('div');
    this.panel.className = 'adjustment-panel';
    this.panel.innerHTML = `
      <div class="panel-header">
        <h3>è°ƒæ•´é€‰é¡¹</h3>
        <span class="current-selection">æœªé€‰æ‹©å…ƒç´ </span>
      </div>
      <div class="panel-content">
        <div class="adjustment-groups">
          <!-- åŠ¨æ€ç”Ÿæˆçš„è°ƒæ•´é€‰é¡¹ -->
        </div>
      </div>
    `;

    this.bindEvents();
  }

  bindEvents() {
    // ç›‘å¬æ—¶é—´è½´é€‰æ‹©å˜åŒ–
    this.timeline.on('selection-changed', (element) => {
      this.setCurrentElement(element);
    });

    // ç›‘å¬å…³é”®å¸§é€‰æ‹©
    this.timeline.on('keyframe-selected', (keyframe) => {
      this.setCurrentKeyframe(keyframe);
    });
  }

  setCurrentElement(element) {
    this.currentElement = element;
    this.updatePanelForElement(element);
  }

  updatePanelForElement(element) {
    const selectionText = element ?
      `${element.type}: ${element.name}` : 'æœªé€‰æ‹©å…ƒç´ ';

    this.panel.querySelector('.current-selection').textContent = selectionText;

    const groupsContainer = this.panel.querySelector('.adjustment-groups');
    groupsContainer.innerHTML = '';

    if (!element) return;

    // æ ¹æ®å…ƒç´ ç±»å‹ç”Ÿæˆè°ƒæ•´é€‰é¡¹
    const adjustmentGroups = this.getAdjustmentsForElement(element);

    adjustmentGroups.forEach(group => {
      groupsContainer.appendChild(this.createAdjustmentGroup(group));
    });
  }

  getAdjustmentsForElement(element) {
    const typeAdjustments = {
      text: [
        {
          name: 'å†…å®¹',
          controls: [
            { type: 'textarea', property: 'content', label: 'æ–‡å­—å†…å®¹' },
            { type: 'color', property: 'color', label: 'æ–‡å­—é¢œè‰²' },
            { type: 'range', property: 'fontSize', label: 'å­—ä½“å¤§å°', min: 12, max: 72 }
          ]
        },
        {
          name: 'åŠ¨ç”»',
          controls: [
            { type: 'select', property: 'animationType', label: 'åŠ¨ç”»ç±»å‹',
              options: ['none', 'fadeIn', 'slideIn', 'scaleIn'] },
            { type: 'range', property: 'animationDuration', label: 'åŠ¨ç”»æ—¶é•¿', min: 0.2, max: 2.0, step: 0.1 }
          ]
        }
      ],
      image: [
        {
          name: 'æ˜¾ç¤º',
          controls: [
            { type: 'range', property: 'opacity', label: 'ä¸é€æ˜åº¦', min: 0, max: 1, step: 0.1 },
            { type: 'range', property: 'scale', label: 'ç¼©æ”¾', min: 0.5, max: 2.0, step: 0.1 }
          ]
        },
        {
          name: 'ä½ç½®',
          controls: [
            { type: 'range', property: 'x', label: 'æ°´å¹³ä½ç½®', min: -100, max: 100 },
            { type: 'range', property: 'y', label: 'å‚ç›´ä½ç½®', min: -100, max: 100 }
          ]
        }
      ],
      video: [
        {
          name: 'æ’­æ”¾',
          controls: [
            { type: 'range', property: 'startTime', label: 'å¼€å§‹æ—¶é—´', min: 0, max: element.duration },
            { type: 'range', property: 'endTime', label: 'ç»“æŸæ—¶é—´', min: 0, max: element.duration },
            { type: 'range', property: 'volume', label: 'éŸ³é‡', min: 0, max: 1, step: 0.1 }
          ]
        },
        {
          name: 'ç”»ä¸­ç”»',
          controls: [
            { type: 'select', property: 'pipPosition', label: 'ä½ç½®',
              options: ['top-left', 'top-right', 'bottom-left', 'bottom-right'] },
            { type: 'range', property: 'pipSize', label: 'å¤§å°', min: 10, max: 50 }
          ]
        }
      ]
    };

    return typeAdjustments[element.type] || [];
  }

  createAdjustmentGroup(group) {
    const groupElement = document.createElement('div');
    groupElement.className = 'adjustment-group';

    const title = document.createElement('h4');
    title.textContent = group.name;
    groupElement.appendChild(title);

    group.controls.forEach(control => {
      const controlElement = this.createControl(control);
      groupElement.appendChild(controlElement);
    });

    return groupElement;
  }

  createControl(controlConfig) {
    const controlElement = document.createElement('div');
    controlElement.className = 'adjustment-control';

    const label = document.createElement('label');
    label.textContent = controlConfig.label;
    controlElement.appendChild(label);

    const input = this.createInputForControl(controlConfig);
    controlElement.appendChild(input);

    return controlElement;
  }

  createInputForControl(control) {
    let input;

    switch (control.type) {
      case 'range':
        input = document.createElement('input');
        input.type = 'range';
        input.min = control.min;
        input.max = control.max;
        input.step = control.step || 1;
        input.value = this.getCurrentValue(control.property);
        input.addEventListener('input', (e) => {
          this.updateProperty(control.property, parseFloat(e.target.value));
        });
        break;

      case 'color':
        input = document.createElement('input');
        input.type = 'color';
        input.value = this.getCurrentValue(control.property);
        input.addEventListener('change', (e) => {
          this.updateProperty(control.property, e.target.value);
        });
        break;

      case 'select':
        input = document.createElement('select');
        control.options.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option;
          optionElement.textContent = option;
          input.appendChild(optionElement);
        });
        input.value = this.getCurrentValue(control.property);
        input.addEventListener('change', (e) => {
          this.updateProperty(control.property, e.target.value);
        });
        break;

      case 'textarea':
        input = document.createElement('textarea');
        input.value = this.getCurrentValue(control.property);
        input.rows = 3;
        input.addEventListener('input', (e) => {
          this.updateProperty(control.property, e.target.value);
        });
        break;
    }

    return input;
  }

  getCurrentValue(property) {
    return this.currentElement ?
      this.currentElement.properties[property] :
      '';
  }

  updateProperty(property, value) {
    if (!this.currentElement) return;

    // æ›´æ–°å…ƒç´ å±æ€§
    this.currentElement.properties[property] = value;

    // é€šçŸ¥é¢„è§ˆç³»ç»Ÿæ›´æ–°
    this.preview.updatePreview({
      elementId: this.currentElement.id,
      property,
      value
    });

    // è§¦å‘å±æ€§å˜åŒ–äº‹ä»¶
    this.emit('property-changed', {
      element: this.currentElement,
      property,
      value
    });
  }
}
```

### 5.8.3 é¢„è§ˆè´¨é‡ç®¡ç†

#### 5.8.3.1 è‡ªé€‚åº”è´¨é‡è°ƒèŠ‚
**æ€§èƒ½ç›‘æ§é©±åŠ¨çš„è´¨é‡è°ƒèŠ‚**:
```javascript
class PreviewQualityManager {
  constructor(previewSystem) {
    this.previewSystem = previewSystem;
    this.performanceMonitor = new PerformanceMonitor();
    this.qualityLevels = {
      high: { fps: 30, resolution: 1.0 },
      medium: { fps: 20, resolution: 0.75 },
      low: { fps: 15, resolution: 0.5 }
    };
    this.currentQuality = 'medium';
  }

  startAdaptiveQuality() {
    this.monitorInterval = setInterval(() => {
      this.checkAndAdjustQuality();
    }, 5000); // æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
  }

  stopAdaptiveQuality() {
    if (this.monitorInterval) {
      clearInterval(this.monitorInterval);
      this.monitorInterval = null;
    }
  }

  async checkAndAdjustQuality() {
    const metrics = await this.performanceMonitor.getMetrics();

    const currentLevel = this.qualityLevels[this.currentQuality];
    const shouldUpgrade = this.shouldUpgradeQuality(metrics, currentLevel);
    const shouldDowngrade = this.shouldDowngradeQuality(metrics, currentLevel);

    if (shouldUpgrade && this.canUpgrade()) {
      await this.upgradeQuality();
    } else if (shouldDowngrade && this.canDowngrade()) {
      await this.downgradeQuality();
    }
  }

  shouldUpgradeQuality(metrics, currentLevel) {
    return metrics.fps > currentLevel.fps * 1.2 && // FPSè¶³å¤Ÿé«˜
           metrics.memoryUsage < 0.7; // å†…å­˜ä½¿ç”¨ç‡ä¸é«˜
  }

  shouldDowngradeQuality(metrics, currentLevel) {
    return metrics.fps < currentLevel.fps * 0.8 || // FPSå¤ªä½
           metrics.memoryUsage > 0.9; // å†…å­˜ä½¿ç”¨ç‡å¤ªé«˜
  }

  canUpgrade() {
    const levels = Object.keys(this.qualityLevels);
    const currentIndex = levels.indexOf(this.currentQuality);
    return currentIndex > 0;
  }

  canDowngrade() {
    const levels = Object.keys(this.qualityLevels);
    const currentIndex = levels.indexOf(this.currentQuality);
    return currentIndex < levels.length - 1;
  }

  async upgradeQuality() {
    const levels = Object.keys(this.qualityLevels);
    const currentIndex = levels.indexOf(this.currentQuality);
    const newQuality = levels[currentIndex - 1];

    await this.setQuality(newQuality);
  }

  async downgradeQuality() {
    const levels = Object.keys(this.qualityLevels);
    const currentIndex = levels.indexOf(this.currentQuality);
    const newQuality = levels[currentIndex + 1];

    await this.setQuality(newQuality);
  }

  async setQuality(quality) {
    if (quality === this.currentQuality) return;

    console.log(`Switching preview quality from ${this.currentQuality} to ${quality}`);
    this.currentQuality = quality;

    // é€šçŸ¥é¢„è§ˆç³»ç»Ÿ
    await this.previewSystem.setQuality(quality);

    // è§¦å‘è´¨é‡å˜åŒ–äº‹ä»¶
    this.emit('quality-changed', quality);
  }
}

class PerformanceMonitor {
  constructor() {
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.fps = 0;
  }

  getMetrics() {
    const now = performance.now();
    const deltaTime = now - this.lastTime;

    if (deltaTime >= 1000) { // æ¯ç§’æ›´æ–°ä¸€æ¬¡
      this.fps = (this.frameCount * 1000) / deltaTime;
      this.frameCount = 0;
      this.lastTime = now;
    }

    // è·å–å†…å­˜ä½¿ç”¨æƒ…å†µï¼ˆå¦‚æœå¯ç”¨ï¼‰
    const memory = performance.memory ? {
      used: performance.memory.usedJSHeapSize,
      total: performance.memory.totalJSHeapSize,
      limit: performance.memory.jsHeapSizeLimit
    } : null;

    return {
      fps: this.fps,
      memoryUsage: memory ? memory.used / memory.limit : 0,
      timestamp: now
    };
  }

  recordFrame() {
    this.frameCount++;
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œé¢„è§ˆä¸è°ƒæ•´åŠŸèƒ½æ˜¯ç”¨æˆ·ä½“éªŒçš„æ ¸å¿ƒï¼Œå®æ—¶åé¦ˆå’Œç²¾ç»†æ§åˆ¶è‡³å…³é‡è¦

---

## äº”ç‚¹ä¹ã€å¯¼å‡ºåŠŸèƒ½æŠ€æœ¯åˆ†æ

### 5.9.1 è§†é¢‘å¯¼å‡ºç³»ç»Ÿ

#### 5.9.1.1 WebCodecs APIå®ç°
**ç¡¬ä»¶åŠ é€Ÿè§†é¢‘ç¼–ç **:
```javascript
class VideoExporter {
  constructor() {
    this.isSupported = this.checkWebCodecsSupport();
    this.encoder = null;
    this.recorder = null;
    this.frames = [];
  }

  async checkWebCodecsSupport() {
    return 'VideoEncoder' in window && 'VideoDecoder' in window;
  }

  async exportVideo(options = {}) {
    const {
      width = 1920,
      height = 1080,
      frameRate = 30,
      bitrate = 8000000,
      format = 'mp4'
    } = options;

    if (!this.isSupported) {
      return this.fallbackExport(options);
    }

    try {
      // åˆå§‹åŒ–ç¼–ç å™¨
      this.encoder = new VideoEncoder({
        output: this.handleEncodedChunk.bind(this),
        error: (error) => console.error('Encoding error:', error)
      });

      await this.encoder.configure({
        codec: 'avc1.42001f', // H.264
        width,
        height,
        bitrate,
        framerate: frameRate
      });

      // ç”Ÿæˆå¸§åºåˆ—
      const frames = await this.generateFrameSequence(options);

      // ç¼–ç æ¯ä¸€å¸§
      for (const frame of frames) {
        const videoFrame = new VideoFrame(frame.canvas, {
          timestamp: frame.timestamp
        });
        this.encoder.encode(videoFrame);
        videoFrame.close();
      }

      // å®Œæˆç¼–ç 
      await this.encoder.flush();
      this.encoder.close();

      // åˆæˆæœ€ç»ˆæ–‡ä»¶
      return await this.createVideoFile(format);

    } catch (error) {
      console.error('WebCodecs export failed:', error);
      return this.fallbackExport(options);
    }
  }

  async generateFrameSequence(options) {
    const frames = [];
    const { duration, width, height } = options;
    const frameInterval = 1000 / options.frameRate;

    for (let time = 0; time < duration; time += frameInterval) {
      const canvas = document.createElement('canvas');
      canvas.width = width;
      canvas.height = height;
      const ctx = canvas.getContext('2d');

      // æ¸²æŸ“å½“å‰æ—¶é—´ç‚¹çš„å¸§
      await this.renderFrameAtTime(ctx, time, options);

      frames.push({
        canvas,
        timestamp: time * 1000 // å¾®ç§’
      });
    }

    return frames;
  }

  async renderFrameAtTime(ctx, time, options) {
    const { template, video, effects } = options;

    // 1. æ¸²æŸ“èƒŒæ™¯
    this.renderBackground(ctx, template);

    // 2. æ¸²æŸ“è§†é¢‘å¸§ï¼ˆå¦‚æœåœ¨æ—¶é—´èŒƒå›´å†…ï¼‰
    if (video && time >= video.startTime && time <= video.endTime) {
      await this.renderVideoFrame(ctx, video, time);
    }

    // 3. æ¸²æŸ“æ¨¡æ¿å…ƒç´ 
    this.renderTemplateElements(ctx, template, time);

    // 4. æ¸²æŸ“åŠ¨æ€æ•ˆæœ
    this.renderEffects(ctx, effects, time);

    // 5. æ·»åŠ æ°´å°
    if (options.watermark) {
      this.addWatermark(ctx, options.watermark);
    }
  }

  handleEncodedChunk(chunk) {
    // æ”¶é›†ç¼–ç åçš„æ•°æ®å—
    this.frames.push(chunk);
  }

  async createVideoFile(format) {
    // ä½¿ç”¨ MP4 muxer åˆæˆæœ€ç»ˆæ–‡ä»¶
    const mp4Muxer = new MP4Muxer({
      target: 'buffer',
      video: {
        codec: 'avc',
        width: this.width,
        height: this.height
      }
    });

    for (const chunk of this.frames) {
      mp4Muxer.addVideoChunk(chunk);
    }

    const buffer = await mp4Muxer.finalize();
    return new Blob([buffer], { type: 'video/mp4' });
  }

  async fallbackExport(options) {
    // ä½¿ç”¨ MediaRecorder API ä½œä¸ºå¤‡é€‰æ–¹æ¡ˆ
    console.log('Using MediaRecorder fallback');

    const canvas = await this.createRenderedCanvas(options);
    const stream = canvas.captureStream(options.frameRate);

    return new Promise(resolve => {
      const chunks = [];
      const recorder = new MediaRecorder(stream, {
        mimeType: 'video/webm;codecs=vp9'
      });

      recorder.ondataavailable = (event) => {
        chunks.push(event.data);
      };

      recorder.onstop = () => {
        const blob = new Blob(chunks, { type: 'video/webm' });
        resolve(blob);
      };

      recorder.start();

      // æ¨¡æ‹Ÿæ’­æ”¾è¿‡ç¨‹
      this.simulatePlayback(canvas, options, () => {
        recorder.stop();
      });
    });
  }

  async createRenderedCanvas(options) {
    // åˆ›å»ºç¦»å±canvasç”¨äºæ¸²æŸ“
    const canvas = document.createElement('canvas');
    canvas.width = options.width;
    canvas.height = options.height;
    const ctx = canvas.getContext('2d');

    // è¿™é‡Œå®ç°å®Œæ•´çš„æ¸²æŸ“é€»è¾‘
    // ...

    return canvas;
  }
}
```

#### 5.9.1.2 éŸ³é¢‘å¤„ç†å’ŒåŒæ­¥
**éŸ³è§†é¢‘åŒæ­¥**:
```javascript
class AudioVideoSynchronizer {
  constructor(videoExporter) {
    this.videoExporter = videoExporter;
    this.audioContext = new AudioContext();
    this.audioBuffer = null;
  }

  async prepareAudio(audioBlob) {
    // è§£ç éŸ³é¢‘
    const arrayBuffer = await audioBlob.arrayBuffer();
    this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
  }

  async mixAudioWithVideo(videoFrames, options) {
    const { sampleRate, channels } = this.audioBuffer;
    const frameDuration = 1 / options.frameRate;

    // ä¸ºæ¯ä¸€å¸§æå–å¯¹åº”çš„éŸ³é¢‘æ ·æœ¬
    const audioSamples = videoFrames.map((frame, index) => {
      const startTime = index * frameDuration;
      const endTime = startTime + frameDuration;

      return this.extractAudioSegment(startTime, endTime);
    });

    return audioSamples;
  }

  extractAudioSegment(startTime, endTime) {
    const startSample = Math.floor(startTime * this.audioBuffer.sampleRate);
    const endSample = Math.floor(endTime * this.audioBuffer.sampleRate);
    const length = endSample - startSample;

    const audioData = new Float32Array(length * this.audioBuffer.numberOfChannels);

    for (let channel = 0; channel < this.audioBuffer.numberOfChannels; channel++) {
      const channelData = this.audioBuffer.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        audioData[i * this.audioBuffer.numberOfChannels + channel] =
          channelData[startSample + i];
      }
    }

    return audioData;
  }
}
```

### 5.9.2 HTMLé¢„è§ˆå¯¼å‡º

#### 5.9.2.1 è‡ªåŒ…å«HTMLç”Ÿæˆ
**ç¦»çº¿å¯ç”¨çš„äº¤äº’å¼é¢„è§ˆ**:
```javascript
class HTMLExporter {
  constructor() {
    this.template = null;
    this.assets = new Map();
  }

  async exportHTML(options = {}) {
    const {
      template,
      video,
      effects,
      title = 'VidSlide AI æ¼”ç¤º',
      description = ''
    } = options;

    // 1. æ”¶é›†æ‰€æœ‰èµ„æº
    await this.collectAssets(template, video, effects);

    // 2. ç”ŸæˆHTMLç»“æ„
    const html = this.generateHTMLStructure(options);

    // 3. å†…è”CSSå’ŒJavaScript
    const styledHtml = await this.inlineAssets(html);

    // 4. åˆ›å»ºå¯ä¸‹è½½çš„HTMLæ–‡ä»¶
    return new Blob([styledHtml], { type: 'text/html' });
  }

  async collectAssets(template, video, effects) {
    // æ”¶é›†æ¨¡æ¿ä¸­çš„å›¾ç‰‡èµ„æº
    if (template.images) {
      for (const image of template.images) {
        const dataUrl = await this.imageToDataUrl(image);
        this.assets.set(image.url, dataUrl);
      }
    }

    // æ”¶é›†è§†é¢‘èµ„æºï¼ˆå¦‚æœéœ€è¦å†…è”ï¼‰
    if (video && options.inlineVideo) {
      const videoDataUrl = await this.videoToDataUrl(video);
      this.assets.set(video.url, videoDataUrl);
    }

    // æ”¶é›†éŸ³é¢‘èµ„æº
    if (effects.audio) {
      for (const audio of effects.audio) {
        const audioDataUrl = await this.audioToDataUrl(audio);
        this.assets.set(audio.url, audioDataUrl);
      }
    }
  }

  generateHTMLStructure(options) {
    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${options.title}</title>
    <meta name="description" content="${options.description}">
    <style>
        ${this.generateCSS(options)}
    </style>
</head>
<body>
    <div class="presentation-container">
        <div class="slide" id="slide-1">
            ${this.generateSlideContent(options)}
        </div>
    </div>

    <script>
        ${this.generateJavaScript(options)}
    </script>
</body>
</html>`;
  }

  generateCSS(options) {
    return `
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }

        .presentation-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .slide {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }

        .content {
            position: relative;
            z-index: 2;
            text-align: center;
        }

        .text-element {
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s ease;
        }

        .text-element.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .pip-video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 320px;
            height: 180px;
            border-radius: 8px;
            overflow: hidden;
            z-index: 3;
        }

        @media (max-width: 768px) {
            .pip-video {
                width: 200px;
                height: 112px;
            }
        }
    `;
  }

  generateSlideContent(options) {
    const { template, video } = options;

    return `
        ${template.background ? `<img class="background" src="${this.assets.get(template.background)}" alt="èƒŒæ™¯">` : ''}

        <div class="content">
            ${template.elements.map(element =>
                this.generateElementHTML(element)
            ).join('')}
        </div>

        ${video ? `
            <div class="pip-video">
                <video id="pip-video" autoplay muted>
                    <source src="${this.assets.get(video.url)}" type="video/mp4">
                </video>
            </div>
        ` : ''}
    `;
  }

  generateElementHTML(element) {
    switch (element.type) {
      case 'text':
        return `<div class="text-element" style="
            font-size: ${element.fontSize || 48}px;
            color: ${element.color || '#fff'};
            font-weight: ${element.bold ? 'bold' : 'normal'};
            margin: 20px 0;
        ">${element.content}</div>`;

      case 'image':
        return `<img class="image-element" src="${this.assets.get(element.url)}"
            style="max-width: 80%; max-height: 60%; margin: 20px 0;" alt="${element.alt || ''}">`;

      default:
        return '';
    }
  }

  generateJavaScript(options) {
    const { effects, video } = options;

    return `
        // åŠ¨ç”»æ§åˆ¶
        class AnimationController {
            constructor() {
                this.currentTime = 0;
                this.animations = ${JSON.stringify(effects.animations || [])};
                this.init();
            }

            init() {
                this.startTime = Date.now();
                this.animate();
            }

            animate() {
                this.currentTime = (Date.now() - this.startTime) / 1000;

                this.updateAnimations();
                requestAnimationFrame(() => this.animate());
            }

            updateAnimations() {
                this.animations.forEach(animation => {
                    if (this.currentTime >= animation.startTime &&
                        this.currentTime <= animation.endTime) {
                        this.playAnimation(animation);
                    }
                });
            }

            playAnimation(animation) {
                const element = document.getElementById(animation.elementId);
                if (!element) return;

                switch (animation.type) {
                    case 'fadeIn':
                        element.classList.add('visible');
                        break;
                    case 'highlight':
                        element.style.textShadow = '0 0 10px rgba(255,215,0,0.8)';
                        break;
                }
            }
        }

        // è§†é¢‘æ§åˆ¶
        ${video ? `
        class VideoController {
            constructor() {
                this.video = document.getElementById('pip-video');
                this.init();
            }

            init() {
                if (this.video) {
                    this.video.addEventListener('loadeddata', () => {
                        this.video.currentTime = ${video.startTime || 0};
                    });
                }
            }
        }
        ` : ''}

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            new AnimationController();
            ${video ? 'new VideoController();' : ''}
        });
    `;
  }

  async inlineAssets(html) {
    // å°†å¤–éƒ¨èµ„æºè½¬æ¢ä¸ºdata URL
    let processedHtml = html;

    for (const [url, dataUrl] of this.assets) {
      processedHtml = processedHtml.replace(new RegExp(url, 'g'), dataUrl);
    }

    return processedHtml;
  }

  async imageToDataUrl(imageUrl) {
    try {
      const response = await fetch(imageUrl);
      const blob = await response.blob();
      return new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    } catch (error) {
      console.error('Failed to convert image to data URL:', error);
      return imageUrl; // è¿”å›åŸURLä½œä¸ºå¤‡é€‰
    }
  }
}
```

### 5.9.3 æ°´å°ç­–ç•¥å®ç°

#### 5.9.3.1 åŠ¨æ€æ°´å°ç³»ç»Ÿ
**ä»˜è´¹çŠ¶æ€æ„ŸçŸ¥çš„æ°´å°**:
```javascript
class WatermarkManager {
  constructor() {
    this.userTier = 'free'; // 'free' | 'premium'
    this.watermarks = {
      free: {
        text: 'Made with VidSlide AI',
        position: 'bottom-right',
        size: '20px',
        opacity: 0.8,
        color: '#ffffff'
      },
      premium: null // æ— æ°´å°
    };
  }

  setUserTier(tier) {
    this.userTier = tier;
  }

  applyWatermark(canvas, options = {}) {
    const watermark = this.getWatermarkConfig();

    if (!watermark) return; // é«˜çº§ç”¨æˆ·æ— æ°´å°

    const ctx = canvas.getContext('2d');
    const { width, height } = canvas;

    // ä¿å­˜å½“å‰çŠ¶æ€
    ctx.save();

    // è®¾ç½®æ°´å°æ ·å¼
    ctx.globalAlpha = watermark.opacity;
    ctx.fillStyle = watermark.color;
    ctx.font = `${watermark.size} Arial`;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';

    // è®¡ç®—ä½ç½®
    const padding = 20;
    let x, y;

    switch (watermark.position) {
      case 'bottom-right':
        x = width - padding;
        y = height - padding;
        break;
      case 'bottom-left':
        ctx.textAlign = 'left';
        x = padding;
        y = height - padding;
        break;
      case 'top-right':
        x = width - padding;
        y = padding + parseInt(watermark.size);
        break;
      case 'top-left':
        ctx.textAlign = 'left';
        x = padding;
        y = padding + parseInt(watermark.size);
        break;
    }

    // æ·»åŠ é˜´å½±æ•ˆæœ
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 2;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;

    // ç»˜åˆ¶æ°´å°
    ctx.fillText(watermark.text, x, y);

    // æ¢å¤çŠ¶æ€
    ctx.restore();
  }

  getWatermarkConfig() {
    return this.watermarks[this.userTier];
  }

  // éšå½¢æ•°å­—æ°´å°ï¼ˆé«˜çº§ç”¨æˆ·ï¼‰
  applyInvisibleWatermark(canvas, userId) {
    if (this.userTier !== 'premium') return;

    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;

    // ä½¿ç”¨ç”¨æˆ·IDç”Ÿæˆæ°´å°æ¨¡å¼
    const watermark = this.generateWatermarkPattern(userId);

    // åœ¨åƒç´ çº§åˆ«åµŒå…¥æ°´å°
    for (let i = 0; i < data.length; i += 4) {
      const pixelIndex = i / 4;
      const watermarkBit = watermark[pixelIndex % watermark.length];

      // å¾®è°ƒåƒç´ å€¼åµŒå…¥æ°´å°ä¿¡æ¯
      if (watermarkBit) {
        data[i] = Math.max(0, data[i] - 1);     // R
        data[i + 1] = Math.max(0, data[i + 1] - 1); // G
      }
    }

    ctx.putImageData(imageData, 0, 0);
  }

  generateWatermarkPattern(userId) {
    // å°†ç”¨æˆ·IDè½¬æ¢ä¸ºäºŒè¿›åˆ¶æ¨¡å¼
    const binary = userId.toString(2);
    const pattern = [];

    for (let i = 0; i < binary.length; i++) {
      pattern.push(binary[i] === '1');
    }

    return pattern;
  }
}
```

### 5.9.4 å¯¼å‡ºè¿›åº¦ç®¡ç†

#### 5.9.4.1 åˆ†é˜¶æ®µè¿›åº¦è·Ÿè¸ª
**ç”¨æˆ·å‹å¥½çš„è¿›åº¦åé¦ˆ**:
```javascript
class ExportProgressManager {
  constructor() {
    this.stages = [
      { id: 'prepare', name: 'å‡†å¤‡å¯¼å‡º', weight: 5 },
      { id: 'render', name: 'æ¸²æŸ“å¸§åºåˆ—', weight: 70 },
      { id: 'encode', name: 'è§†é¢‘ç¼–ç ', weight: 20 },
      { id: 'finalize', name: 'å®Œæˆå¯¼å‡º', weight: 5 }
    ];
    this.currentStage = null;
    this.overallProgress = 0;
    this.stageProgress = 0;
  }

  startExport() {
    this.reset();
    this.emit('export-started');
  }

  updateProgress(stageId, progress, details = {}) {
    this.currentStage = this.stages.find(s => s.id === stageId);
    this.stageProgress = Math.max(0, Math.min(100, progress));

    // è®¡ç®—æ€»ä½“è¿›åº¦
    const completedWeight = this.stages
      .filter(s => s.id !== stageId)
      .reduce((sum, s) => sum + s.weight, 0);

    this.overallProgress = completedWeight +
      (this.currentStage.weight * this.stageProgress / 100);

    this.emit('progress-updated', {
      stage: this.currentStage,
      stageProgress: this.stageProgress,
      overallProgress: Math.round(this.overallProgress),
      details
    });
  }

  completeStage(stageId) {
    if (this.currentStage && this.currentStage.id === stageId) {
      this.stageProgress = 100;
      this.updateProgress(stageId, 100);
    }
  }

  finishExport(result) {
    this.overallProgress = 100;
    this.emit('export-completed', result);
  }

  failExport(error) {
    this.emit('export-failed', error);
  }

  reset() {
    this.currentStage = null;
    this.overallProgress = 0;
    this.stageProgress = 0;
  }

  getEstimatedTime(stageId, progress) {
    // åŸºäºå†å²æ•°æ®ä¼°ç®—å‰©ä½™æ—¶é—´
    const stage = this.stages.find(s => s.id === stageId);
    if (!stage) return null;

    const remainingWork = (100 - progress) / 100;
    const avgTimePerUnit = this.getAverageTimePerUnit(stageId);

    return remainingWork * avgTimePerUnit;
  }

  getAverageTimePerUnit(stageId) {
    // ä»localStorageè·å–å†å²å¹³å‡æ—¶é—´
    const history = JSON.parse(localStorage.getItem('export-history') || '[]');
    const stageHistory = history.filter(h => h.stage === stageId);

    if (stageHistory.length === 0) return this.getDefaultTime(stageId);

    const avgTime = stageHistory.reduce((sum, h) => sum + h.time, 0) / stageHistory.length;
    return avgTime;
  }

  getDefaultTime(stageId) {
    const defaults = {
      prepare: 1000,   // 1ç§’
      render: 50000,   // 50ç§’
      encode: 15000,   // 15ç§’
      finalize: 2000   // 2ç§’
    };
    return defaults[stageId] || 10000;
  }

  recordStageTime(stageId, time) {
    const history = JSON.parse(localStorage.getItem('export-history') || '[]');
    history.push({
      stage: stageId,
      time,
      timestamp: Date.now()
    });

    // ä¿ç•™æœ€è¿‘50æ¡è®°å½•
    if (history.length > 50) {
      history.shift();
    }

    localStorage.setItem('export-history', JSON.stringify(history));
  }
}

// UIè¿›åº¦æ˜¾ç¤ºç»„ä»¶
class ExportProgressUI {
  constructor(container) {
    this.container = container;
    this.progressManager = new ExportProgressManager();
    this.init();
  }

  init() {
    this.progressManager.on('export-started', () => this.showProgress());
    this.progressManager.on('progress-updated', (data) => this.updateProgress(data));
    this.progressManager.on('export-completed', (result) => this.showCompletion(result));
    this.progressManager.on('export-failed', (error) => this.showError(error));
  }

  showProgress() {
    this.container.innerHTML = `
      <div class="export-progress-overlay">
        <div class="progress-dialog">
          <h3>æ­£åœ¨å¯¼å‡ºè§†é¢‘</h3>
          <div class="overall-progress">
            <div class="progress-bar">
              <div class="progress-fill" style="width: 0%"></div>
            </div>
            <div class="progress-text">0%</div>
          </div>
          <div class="stage-progress">
            <div class="stage-name">å‡†å¤‡ä¸­...</div>
            <div class="stage-bar">
              <div class="stage-fill" style="width: 0%"></div>
            </div>
          </div>
          <div class="estimated-time">é¢„è®¡å‰©ä½™æ—¶é—´: è®¡ç®—ä¸­...</div>
          <button class="cancel-btn">å–æ¶ˆå¯¼å‡º</button>
        </div>
      </div>
    `;

    this.bindEvents();
  }

  updateProgress(data) {
    const { overallProgress, stage, stageProgress, details } = data;

    // æ›´æ–°æ€»ä½“è¿›åº¦
    const overallFill = this.container.querySelector('.progress-fill');
    const overallText = this.container.querySelector('.progress-text');
    overallFill.style.width = `${overallProgress}%`;
    overallText.textContent = `${overallProgress}%`;

    // æ›´æ–°é˜¶æ®µè¿›åº¦
    const stageName = this.container.querySelector('.stage-name');
    const stageFill = this.container.querySelector('.stage-fill');
    stageName.textContent = stage.name;
    stageFill.style.width = `${stageProgress}%`;

    // æ›´æ–°é¢„è®¡æ—¶é—´
    const estimatedTime = this.container.querySelector('.estimated-time');
    const remaining = this.progressManager.getEstimatedTime(stage.id, stageProgress);
    if (remaining) {
      const minutes = Math.floor(remaining / 60000);
      const seconds = Math.floor((remaining % 60000) / 1000);
      estimatedTime.textContent = `é¢„è®¡å‰©ä½™æ—¶é—´: ${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
  }

  showCompletion(result) {
    // æ˜¾ç¤ºå®ŒæˆçŠ¶æ€å’Œä¸‹è½½é“¾æ¥
    this.container.innerHTML = `
      <div class="export-complete-overlay">
        <div class="complete-dialog">
          <div class="success-icon">âœ…</div>
          <h3>å¯¼å‡ºå®Œæˆ</h3>
          <p>è§†é¢‘å·²æˆåŠŸå¯¼å‡º</p>
          <div class="export-info">
            <div class="file-size">æ–‡ä»¶å¤§å°: ${this.formatFileSize(result.size)}</div>
            <div class="duration">æ—¶é•¿: ${this.formatDuration(result.duration)}</div>
          </div>
          <div class="action-buttons">
            <button class="download-btn">ä¸‹è½½è§†é¢‘</button>
            <button class="preview-btn">é¢„è§ˆ</button>
            <button class="close-btn">å…³é—­</button>
          </div>
        </div>
      </div>
    `;

    this.bindCompletionEvents(result);
  }

  showError(error) {
    this.container.innerHTML = `
      <div class="export-error-overlay">
        <div class="error-dialog">
          <div class="error-icon">âŒ</div>
          <h3>å¯¼å‡ºå¤±è´¥</h3>
          <p>${error.message}</p>
          <div class="error-details">${error.details || ''}</div>
          <div class="action-buttons">
            <button class="retry-btn">é‡è¯•</button>
            <button class="close-btn">å…³é—­</button>
          </div>
        </div>
      </div>
    `;
  }

  formatFileSize(bytes) {
    const units = ['B', 'KB', 'MB', 'GB'];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
      size /= 1024;
      unitIndex++;
    }

    return `${size.toFixed(1)} ${units[unitIndex]}`;
  }

  formatDuration(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
  }

  bindEvents() {
    const cancelBtn = this.container.querySelector('.cancel-btn');
    cancelBtn?.addEventListener('click', () => {
      this.progressManager.cancelExport();
    });
  }

  bindCompletionEvents(result) {
    const downloadBtn = this.container.querySelector('.download-btn');
    const previewBtn = this.container.querySelector('.preview-btn');
    const closeBtn = this.container.querySelector('.close-btn');

    downloadBtn?.addEventListener('click', () => {
      this.downloadFile(result.blob, result.filename);
    });

    previewBtn?.addEventListener('click', () => {
      this.previewFile(result.blob);
    });

    closeBtn?.addEventListener('click', () => {
      this.hide();
    });
  }

  downloadFile(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  previewFile(blob) {
    const url = URL.createObjectURL(blob);
    const video = document.createElement('video');
    video.src = url;
    video.controls = true;

    // æ˜¾ç¤ºé¢„è§ˆå¯¹è¯æ¡†
    const previewDialog = document.createElement('div');
    previewDialog.className = 'preview-dialog';
    previewDialog.innerHTML = `
      <div class="preview-content">
        <div class="preview-header">
          <h4>å¯¼å‡ºé¢„è§ˆ</h4>
          <button class="close-preview">Ã—</button>
        </div>
        <div class="video-container">
        </div>
      </div>
    `;

    previewDialog.querySelector('.video-container').appendChild(video);
    previewDialog.querySelector('.close-preview').addEventListener('click', () => {
      previewDialog.remove();
      URL.revokeObjectURL(url);
    });

    document.body.appendChild(previewDialog);
  }

  hide() {
    this.container.innerHTML = '';
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œå¯¼å‡ºåŠŸèƒ½æ˜¯äº§å“é—­ç¯çš„å…³é”®ï¼ŒWebCodecs APIæä¾›äº†ç°ä»£åŒ–çš„è§£å†³æ–¹æ¡ˆ

---

## å…­ã€éåŠŸèƒ½éœ€æ±‚æŠ€æœ¯åˆ†æ

### 6.1 æ€§èƒ½è¦æ±‚åˆ†æ

#### 6.1.1 å¤„ç†é€Ÿåº¦ç›®æ ‡
| æŒ‡æ ‡ | ç›®æ ‡ | å½“å‰å¯è¡Œæ€§ | ä¼˜åŒ–ç©ºé—´ |
|------|------|------------|----------|
| **1åˆ†é’Ÿè§†é¢‘å¤„ç†** | â‰¤30ç§’ | â­â­â­ (ä¸­ç­‰) | WebAssemblyåŠ é€Ÿ |
| **å“åº”æ—¶é—´** | â‰¤100ms | â­â­â­â­â­ (é«˜) | äº‹ä»¶å§”æ‰˜ä¼˜åŒ– |
| **å¸§ç‡** | â‰¥25fps | â­â­â­â­ (è¾ƒé«˜) | GPUåŠ é€Ÿ |
| **å†…å­˜å ç”¨** | â‰¤512MB | â­â­â­ (ä¸­ç­‰) | å†…å­˜æ± ç®¡ç† |

#### 6.1.2 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**å†…å­˜ç®¡ç†**:
```javascript
class MemoryManager {
  constructor() {
    this.pools = {
      video: new ObjectPool(VideoBuffer, 3),
      image: new ObjectPool(ImageBuffer, 10),
      audio: new ObjectPool(AudioBuffer, 5)
    };
  }

  acquire(type) {
    return this.pools[type].acquire();
  }

  release(type, object) {
    return this.pools[type].release(object);
  }
}
```

**è®¡ç®—ä¼˜åŒ–**:
- Web Workeråˆ†æ‹…CPUå¯†é›†ä»»åŠ¡
- WebAssemblyåŠ é€Ÿæ•°å­¦è®¡ç®—
- GPUåŠ é€Ÿè§†é¢‘å¤„ç†

### 6.2 å…¼å®¹æ€§åˆ†æ

#### 6.2.1 æµè§ˆå™¨æ”¯æŒçŸ©é˜µ
| åŠŸèƒ½æ¨¡å— | Chrome | Firefox | Safari | Edge |
|----------|--------|---------|--------|------|
| **File API** | âœ… 100% | âœ… 95% | âœ… 80% | âœ… 100% |
| **Web Audio** | âœ… 100% | âœ… 95% | âœ… 80% | âœ… 100% |
| **Canvas 2D** | âœ… 100% | âœ… 95% | âœ… 80% | âœ… 100% |
| **WebGL** | âœ… 100% | âœ… 90% | âœ… 70% | âœ… 100% |
| **WebAssembly** | âœ… 100% | âœ… 95% | âœ… 60% | âœ… 100% |
| **IndexedDB** | âœ… 100% | âœ… 95% | âœ… 80% | âœ… 100% |

#### 6.2.2 é™çº§ç­–ç•¥
```javascript
class CompatibilityManager {
  detectCapabilities() {
    return {
      webgl: this.detectWebGL(),
      wasm: this.detectWebAssembly(),
      webAudio: this.detectWebAudio(),
      indexedDB: this.detectIndexedDB()
    };
  }

  getOptimalConfig(capabilities) {
    if (capabilities.webgl && capabilities.wasm) {
      return 'full-featured';
    } else if (capabilities.webgl) {
      return 'webgl-only';
    } else {
      return 'canvas-fallback';
    }
  }
}
```

### 6.3 å®‰å…¨ä¸éšç§å®ç°

#### 6.3.1 æ•°æ®å¤„ç†ç­–ç•¥
**é›¶ä¸Šä¼ åŸåˆ™å®ç°**:
```javascript
class PrivacyManager {
  constructor() {
    this.processingMode = 'local-only'; // 'local-only' | 'hybrid'
    this.externalRequests = [];
  }

  async processVideo(videoBlob) {
    // æ‰€æœ‰å¤„ç†åœ¨æœ¬åœ°å®Œæˆ
    const analysis = await this.localAnalysis(videoBlob);
    const materials = await this.localMaterialSearch(analysis.keywords);

    if (materials.sufficient) {
      return await this.localRender(analysis, materials);
    } else if (this.processingMode === 'hybrid') {
      return await this.hybridProcess(analysis);
    }
  }
}
```

#### 6.3.2 æˆæƒæ§åˆ¶æœºåˆ¶
```javascript
class AuthorizationManager {
  async requestExternalAccess(purpose, data) {
    const dialog = new AuthorizationDialog({
      purpose,
      dataDescription: this.describeData(data),
      apis: this.getRequiredAPIs(),
      retention: 'session-only'
    });

    const granted = await dialog.show();
    if (granted) {
      this.recordAuthorization(purpose, data);
    }
    return granted;
  }
}
```

### 6.4 å¯è®¿é—®æ€§å®ç°

#### 6.4.1 ARIAæ ‡ç­¾ç³»ç»Ÿ
```javascript
class AccessibilityManager {
  enhanceElement(element, role, properties) {
    element.setAttribute('role', role);

    if (properties.label) {
      element.setAttribute('aria-label', properties.label);
    }

    if (properties.description) {
      element.setAttribute('aria-description', properties.description);
    }

    // é”®ç›˜å¯¼èˆªæ”¯æŒ
    if (properties.keyboard) {
      element.setAttribute('tabindex', '0');
      element.addEventListener('keydown', this.handleKeydown.bind(this));
    }
  }
}
```

**æ€»ä½“è¯„ä¼°**: âœ… **æŠ€æœ¯å¯è¡Œ**ï¼Œæ€§èƒ½å’Œå…¼å®¹æ€§æ˜¯ä¸»è¦æŒ‘æˆ˜ï¼Œä½†éƒ½æœ‰æˆç†Ÿçš„è§£å†³æ–¹æ¡ˆ

---

## ä¸ƒã€æ€»ä½“æŠ€æœ¯è¯„ä¼°ä¸å»ºè®®

### 7.1 æŠ€æœ¯å¯è¡Œæ€§æ€»ç»“

| æ¨¡å— | å¯è¡Œæ€§è¯„åˆ† | é£é™©ç­‰çº§ | å¼€å‘å‘¨æœŸ(äººæœˆ) |
|------|------------|----------|----------------|
| **æ ¸å¿ƒå·¥ä½œæµç¨‹** | â­â­â­â­â­ | ä½ | 2-3 |
| **ç”»ä¸­ç”»åŠŸèƒ½** | â­â­â­â­ | ä¸­ | 3-4 |
| **AIå†…å®¹åˆ†æ** | â­â­â­ | é«˜ | 4-6 |
| **ç´ æè·å–** | â­â­â­â­ | ä¸­ | 2-3 |
| **æ¨¡æ¿ç³»ç»Ÿ** | â­â­â­â­â­ | ä½ | 2-3 |
| **ç”¨æˆ·è°ƒæ•´** | â­â­â­â­â­ | ä½ | 1-2 |
| **åŠ¨æ€æ•ˆæœ** | â­â­â­â­ | ä¸­ | 2-3 |
| **å¯¼å‡ºåŠŸèƒ½** | â­â­â­â­ | ä¸­ | 2-3 |
| **éåŠŸèƒ½éœ€æ±‚** | â­â­â­â­ | ä¸­ | 3-4 |

### 7.2 å…³é”®æŠ€æœ¯é£é™©

#### é«˜é£é™©é¡¹ç›®
1. **AIæ¨ç†æ€§èƒ½**: æ¨¡å‹å¤§å° vs æ¨ç†é€Ÿåº¦å¹³è¡¡
2. **äººè„¸è·Ÿè¸ªç²¾åº¦**: å¤æ‚åœºæ™¯ä¸‹çš„ç¨³å®šæ€§
3. **è·¨æµè§ˆå™¨å…¼å®¹**: Safari WebAssemblyæ”¯æŒ

#### ä¸­é£é™©é¡¹ç›®
1. **å†…å­˜ç®¡ç†**: å¤§è§†é¢‘æ–‡ä»¶å¤„ç†
2. **ç½‘ç»œè¯·æ±‚ä¼˜åŒ–**: ç´ æä¸‹è½½é˜Ÿåˆ—ç®¡ç†
3. **å®æ—¶é¢„è§ˆæ€§èƒ½**: å¤æ‚æ¨¡æ¿æ¸²æŸ“

### 7.3 å®æ–½å»ºè®®

#### 7.3.1 åˆ†é˜¶æ®µå¼€å‘ç­–ç•¥
**é˜¶æ®µä¸€ (MVP 1.0)**: æ ¸å¿ƒåŠŸèƒ½éªŒè¯
- åŸºç¡€ç”»ä¸­ç”»åŠŸèƒ½
- æœ¬åœ°ç´ æåº“
- 3ä¸ªæ ¸å¿ƒæ¨¡æ¿
- åŸºç¡€å¯¼å‡ºåŠŸèƒ½

**é˜¶æ®µäºŒ (MVP 1.5)**: åŠŸèƒ½å¢å¼º
- AIå†…å®¹åˆ†æ
- å¤–éƒ¨ç´ æé›†æˆ
- é«˜çº§æ¨¡æ¿
- æ€§èƒ½ä¼˜åŒ–

**é˜¶æ®µä¸‰ (MVP 2.0)**: å®Œæ•´äº§å“
- æ‰€æœ‰æ¨¡æ¿ç±»å‹
- ä¼ä¸šçº§åŠŸèƒ½
- é«˜çº§AIç‰¹æ€§

#### 7.3.2 æŠ€æœ¯æ ˆæ¨è
```json
{
  "frontend": {
    "framework": "Vue 3 + Composition API",
    "state": "Pinia",
    "rendering": "Canvas 2D + WebGL",
    "ai": "TensorFlow.js + WebAssembly",
    "storage": "IndexedDB + Service Worker",
    "build": "Vite"
  },
  "external": {
    "speech": "Coqui STT (æœ¬åœ°) + Azure (å¤‡é€‰)",
    "images": "Unsplash, Pexels, Pixabay APIs",
    "fonts": "Google Fonts (æœ¬åœ°ç¼“å­˜)"
  }
}
```

#### 7.3.3 è´¨é‡ä¿è¯æªæ–½
1. **å•å…ƒæµ‹è¯•**: æ ¸å¿ƒç®—æ³• 100% è¦†ç›–
2. **é›†æˆæµ‹è¯•**: å®Œæ•´å·¥ä½œæµç¨‹æµ‹è¯•
3. **æ€§èƒ½æµ‹è¯•**: å¤šè®¾å¤‡å…¼å®¹æ€§æµ‹è¯•
4. **ç”¨æˆ·æµ‹è¯•**: å¯ç”¨æ€§æµ‹è¯•å’Œåé¦ˆæ”¶é›†

### 7.4 é¡¹ç›®æˆåŠŸå…³é”®å› ç´ 

#### æŠ€æœ¯æˆåŠŸå› ç´ 
1. **æ€§èƒ½ä¼˜åŒ–**: ç¡®ä¿1åˆ†é’Ÿè§†é¢‘30ç§’å¤„ç†
2. **éšç§ä¿æŠ¤**: 100%æœ¬åœ°åŒ–å¤„ç†
3. **å…¼å®¹æ€§**: æ”¯æŒä¸»æµæµè§ˆå™¨
4. **å¯æ‰©å±•æ€§**: æ¨¡å—åŒ–æ¶æ„ä¾¿äºåŠŸèƒ½æ‰©å±•

#### ä¸šåŠ¡æˆåŠŸå› ç´ 
1. **ç”¨æˆ·ä½“éªŒ**: ç®€åŒ–æ“ä½œæµç¨‹
2. **å†…å®¹è´¨é‡**: AIç”Ÿæˆæ•ˆæœä¸“ä¸šæ€§
3. **ç´ æä¸°å¯Œæ€§**: è¦†ç›–80%ä½¿ç”¨åœºæ™¯
4. **ä»˜è´¹è½¬åŒ–**: åˆç†çš„å•†ä¸šæ¨¡å¼

### 7.5 ç»“è®º

## åã€ä¸€äººå¼€å‘é‡æ–°è¯„ä¼°

### 10.1 ç°å®æƒ…å†µåˆ†æ

**ä¸€äººå¼€å‘çš„å®¢è§‚é™åˆ¶**:
- **æ—¶é—´èµ„æº**: å…¨èŒå·¥ä½œ + é¡¹ç›®å¼€å‘ï¼Œå®é™…å¯ç”¨æ—¶é—´æœ‰é™
- **æŠ€æœ¯å¹¿åº¦**: éœ€è¦æŒæ¡å‰ç«¯ã€AIã€éŸ³è§†é¢‘å¤„ç†ç­‰å¤šé¢†åŸŸæŠ€æœ¯
- **å­¦ä¹ æ›²çº¿**: å¾ˆå¤šæŠ€æœ¯éœ€è¦ä»é›¶å­¦ä¹ å’Œå®è·µ
- **æµ‹è¯•éªŒè¯**: ç¼ºä¹å›¢é˜Ÿreviewï¼Œè´¨é‡æŠŠæ§éš¾åº¦å¤§
- **ç»´æŠ¤æˆæœ¬**: ä»£ç è´¨é‡ç›´æ¥å½±å“é•¿æœŸç»´æŠ¤æ•ˆç‡

### 10.2 å½“å‰è¯„ä¼°çš„ä¸è¶³

#### 10.2.1 æ—¶é—´ä¼°ç®—è¿‡äºä¹è§‚
**åŸè¯„ä¼°**: 12-16å‘¨å®ŒæˆMVP
**ç°å®è¯„ä¼°**: 24-36å‘¨æ›´åˆç†
- AIåŠŸèƒ½å¼€å‘å‘¨æœŸè¢«ä½ä¼°
- é›†æˆæµ‹è¯•æ—¶é—´ä¸è¶³
- UI/UXæ‰“ç£¨éœ€è¦æ›´å¤šæ—¶é—´

#### 10.2.2 æŠ€æœ¯å¤æ‚åº¦è¿‡é«˜
**é«˜é£é™©é¡¹ç›®**:
1. **äººè„¸è·Ÿè¸ª**: MediaPipeå®ç°å¤æ‚åº¦é«˜ï¼Œè°ƒè¯•å›°éš¾
2. **è¯­éŸ³è¯†åˆ«**: å¤šè¯­è¨€æ”¯æŒéœ€è¦å¤§é‡æµ‹è¯•
3. **è§†é¢‘ç¼–ç **: WebCodecså…¼å®¹æ€§é—®é¢˜å¤š

#### 10.2.3 MVPèŒƒå›´è¿‡å¤§
**å»ºè®®ç²¾ç®€çš„æ ¸å¿ƒåŠŸèƒ½**:
- åŸºç¡€ç”»ä¸­ç”»ï¼ˆå›ºå®šä½ç½®ï¼Œæ— AIè·Ÿè¸ªï¼‰
- 3-5ä¸ªç®€å•æ¨¡æ¿
- æœ¬åœ°ç´ æåº“ä¼˜å…ˆ
- åŸºç¡€å¯¼å‡ºåŠŸèƒ½

### 10.3 ä¸€äººå¼€å‘ä¼˜åŒ–å»ºè®®

#### 10.3.1 æŠ€æœ¯æ ˆè°ƒæ•´
```json
{
  "æ ¸å¿ƒæŠ€æœ¯æ ˆ": {
    "å‰ç«¯æ¡†æ¶": "Vue 3 + Composition API",
    "UIç»„ä»¶": "Element Plus (å¿«é€Ÿå¼€å‘)",
    "çŠ¶æ€ç®¡ç†": "Pinia",
    "æ„å»ºå·¥å…·": "Vite",
    "æ ·å¼": "Tailwind CSS (å¿«é€Ÿå¸ƒå±€)"
  },
  "AIèƒ½åŠ›": {
    "è¯­éŸ³è¯†åˆ«": "Web Speech API + ç¬¬ä¸‰æ–¹æœåŠ¡",
    "å›¾åƒå¤„ç†": "Canvas 2D API + ç®€å•ç®—æ³•",
    "æ–‡æœ¬åˆ†æ": "è½»é‡çº§NLPåº“"
  },
  "éŸ³è§†é¢‘": {
    "æ’­æ”¾": "HTML5 Video API",
    "å¯¼å‡º": "MediaRecorder API (ç®€åŒ–ç‰ˆ)"
  }
}
```

#### 10.3.2 MVPåŠŸèƒ½ç²¾ç®€
**é˜¶æ®µä¸€ (8-12å‘¨)**: æ ¸å¿ƒéªŒè¯
- âœ… è§†é¢‘ä¸Šä¼ å’ŒåŸºç¡€æ’­æ”¾
- âœ… æ‰‹åŠ¨æ·»åŠ æ–‡å­—å¡ç‰‡
- âœ… ç®€å•ç”»ä¸­ç”»ï¼ˆå›ºå®šä½ç½®ï¼‰
- âœ… åŸºç¡€å¯¼å‡ºï¼ˆæˆªå›¾/PDFï¼‰
- âœ… æœ¬åœ°ç´ æåº“

**é˜¶æ®µäºŒ (8-12å‘¨)**: AIå¢å¼º
- âœ… è¯­éŸ³è½¬æ–‡å­—ï¼ˆWeb Speech APIï¼‰
- âœ… å…³é”®è¯æå–ï¼ˆè§„åˆ™å¼•æ“ï¼‰
- âœ… æ™ºèƒ½æ¨¡æ¿æ¨è
- âœ… å¤–éƒ¨ç´ æé›†æˆ

**é˜¶æ®µä¸‰ (8-12å‘¨)**: å®Œæ•´äº§å“
- âœ… äººè„¸è·Ÿè¸ªï¼ˆç®€åŒ–ç‰ˆï¼‰
- âœ… é«˜çº§åŠ¨ç”»æ•ˆæœ
- âœ… å¤šæ ¼å¼å¯¼å‡º
- âœ… ç”¨æˆ·ç³»ç»Ÿ

#### 10.3.3 å¼€å‘ç­–ç•¥ä¼˜åŒ–

**æ¸è¿›å¼å¼€å‘åŸåˆ™**:
1. **åŠŸèƒ½æœ€å°åŒ–**: ä»æœ€æ ¸å¿ƒåŠŸèƒ½å¼€å§‹ï¼Œæ¯å‘¨äº¤ä»˜å¯æ¼”ç¤ºç‰ˆæœ¬
2. **æŠ€æœ¯å€ºåŠ¡ç®¡ç†**: å®šæœŸé‡æ„ï¼Œé¿å…æŠ€æœ¯å€ºåŠ¡ç§¯ç´¯
3. **ç”¨æˆ·åé¦ˆé©±åŠ¨**: æ—©æœŸå¯»æ‰¾ç§å­ç”¨æˆ·ï¼Œè·å–çœŸå®åé¦ˆ
4. **å¼€æºä¼˜å…ˆ**: å€Ÿé‰´æˆç†Ÿå¼€æºæ–¹æ¡ˆï¼Œå‡å°‘é‡å¤é€ è½®å­

**è´¨é‡ä¿è¯ç­–ç•¥**:
1. **è‡ªåŠ¨åŒ–æµ‹è¯•**: é‡ç‚¹æµ‹è¯•æ ¸å¿ƒåŠŸèƒ½ï¼Œè¦†ç›–ç‡60%+
2. **ä»£ç å®¡æŸ¥**: å®šæœŸreviewè‡ªå·±çš„ä»£ç 
3. **æ€§èƒ½ç›‘æ§**: å†…ç½®æ€§èƒ½ç›‘æ§ï¼Œä»å¼€å‘æ—©æœŸå¼€å§‹
4. **é”™è¯¯æ”¶é›†**: å®ç°é”™è¯¯æ”¶é›†ï¼Œä¾¿äºé—®é¢˜å®šä½

#### 10.3.4 èµ„æºè·å–ç­–ç•¥

**æŠ€æœ¯èµ„æº**:
- **å¼€æºä¼˜å…ˆ**: ä½¿ç”¨æˆç†Ÿçš„å¼€æºåº“å’Œç»„ä»¶
- **APIæœåŠ¡**: è¯­éŸ³è¯†åˆ«ã€ç¿»è¯‘ç­‰ä½¿ç”¨äº‘API
- **æ¨¡æ¿å€Ÿé‰´**: å­¦ä¹ ç°æœ‰äº§å“çš„äº¤äº’è®¾è®¡

**äººåŠ›æ”¯æŒ**:
- **ç¤¾åŒºæ±‚åŠ©**: GitHubã€Stack Overflowç­‰æŠ€æœ¯ç¤¾åŒº
- **ä»˜è´¹å’¨è¯¢**: å…³é”®æŠ€æœ¯ç‚¹å¯è€ƒè™‘ä»˜è´¹å’¨è¯¢
- **ç§å­ç”¨æˆ·**: æ—©æœŸç”¨æˆ·å¯æä¾›åé¦ˆå’Œæµ‹è¯•

### 10.4 é£é™©é‡æ–°è¯„ä¼°

#### é«˜é£é™©é¡¹ç›®é‡æ–°æ’åº
1. **AIäººè„¸è·Ÿè¸ª** â†’ **é™çº§ä¸ºæ‰‹åŠ¨è°ƒæ•´**
2. **å¤šè¯­è¨€è¯­éŸ³è¯†åˆ«** â†’ **å…ˆæ”¯æŒä¸­æ–‡+è‹±æ–‡**
3. **å®æ—¶è§†é¢‘ç¼–ç ** â†’ **ä½¿ç”¨MediaRecorder + æœåŠ¡ç«¯å¤„ç†**

#### å¤‡é€‰æ–¹æ¡ˆè®¾è®¡
```javascript
// äººè„¸è·Ÿè¸ªå¤‡é€‰æ–¹æ¡ˆ
class SimplifiedFaceTracker {
  // ä¸ä½¿ç”¨AIï¼Œæ”¹ä¸ºæ‰‹åŠ¨é€‰æ‹©æ„Ÿå…´è¶£åŒºåŸŸ
  selectRegion(videoElement) {
    // ç”¨æˆ·æ‰‹åŠ¨æ¡†é€‰äººè„¸åŒºåŸŸ
    return new Promise(resolve => {
      // å®ç°æ‹–æ‹½é€‰æ‹©åŒºåŸŸçš„é€»è¾‘
    });
  }

  trackRegion(videoElement, region) {
    // ç®€å•çš„ä½ç½®ä¿æŒï¼Œä¸åšæ™ºèƒ½è·Ÿè¸ª
    // è·Ÿéšè§†é¢‘ç¼©æ”¾æ¯”ä¾‹è°ƒæ•´
  }
}

// è¯­éŸ³è¯†åˆ«å¤‡é€‰æ–¹æ¡ˆ
class SpeechRecognitionManager {
  constructor() {
    this.useWebAPI = 'webkitSpeechRecognition' in window;
    this.fallback = new ExternalSpeechService();
  }

  async recognize(audioBlob) {
    if (this.useWebAPI) {
      return this.webSpeechRecognition(audioBlob);
    } else {
      return this.fallback.recognize(audioBlob);
    }
  }
}
```

### 10.5 ä¸€äººå¼€å‘è·¯çº¿å›¾

#### ç¬¬ä¸€é˜¶æ®µ: åŸºç¡€åŸå‹ (4-6å‘¨)
**ç›®æ ‡**: éªŒè¯æ ¸å¿ƒæ¦‚å¿µï¼Œå¯æ¼”ç¤ºçš„åŸå‹
```
Week 1-2: åŸºç¡€UIå’Œè§†é¢‘æ’­æ”¾
Week 3-4: æ–‡å­—å¡ç‰‡æ·»åŠ åŠŸèƒ½
Week 5-6: ç®€å•å¯¼å‡ºå’Œä¼˜åŒ–
```

#### ç¬¬äºŒé˜¶æ®µ: AIå¢å¼º (6-8å‘¨)
**ç›®æ ‡**: æ·»åŠ æ™ºèƒ½åŠŸèƒ½ï¼Œæå‡ç”¨æˆ·ä½“éªŒ
```
Week 7-10: è¯­éŸ³è¯†åˆ«é›†æˆ
Week 11-12: æ™ºèƒ½æ¨¡æ¿æ¨è
Week 13-14: å¤–éƒ¨ç´ æé›†æˆ
```

#### ç¬¬ä¸‰é˜¶æ®µ: äº§å“å®Œå–„ (6-8å‘¨)
**ç›®æ ‡**: å®Œæ•´äº§å“ï¼Œå‡†å¤‡ä¸Šçº¿
```
Week 15-18: é«˜çº§åŠŸèƒ½å’Œä¼˜åŒ–
Week 19-20: æµ‹è¯•å’ŒBugä¿®å¤
Week 21-22: ç”¨æˆ·ç³»ç»Ÿå’Œéƒ¨ç½²
```

### 10.6 æˆåŠŸå…³é”®å› ç´ 

#### æŠ€æœ¯æˆåŠŸè¦ç´ 
1. **ä¿æŒç®€å•**: ä»ç®€å•åŠŸèƒ½å¼€å§‹ï¼Œé€æ­¥å¤æ‚åŒ–
2. **å¿«é€Ÿè¿­ä»£**: æ¯å‘¨æœ‰å¯æ¼”ç¤ºçš„è¿›å±•
3. **è´¨é‡ç¬¬ä¸€**: é‡è§†ä»£ç è´¨é‡ï¼Œé¿å…é‡å†™
4. **ç”¨æˆ·ä¸ºä¸­å¿ƒ**: å§‹ç»ˆå…³æ³¨ç”¨æˆ·å®é™…éœ€æ±‚

#### å•†ä¸šæˆåŠŸè¦ç´ 
1. **æ—©æœŸéªŒè¯**: å°½æ—©æ‰¾åˆ°ç§å­ç”¨æˆ·
2. **å£ç¢‘ä¼ æ’­**: åšå‡ºçœŸæ­£æœ‰ä»·å€¼çš„äº§å“
3. **æŒç»­è¿è¥**: å»ºç«‹ç”¨æˆ·åé¦ˆæœºåˆ¶
4. **çµæ´»è°ƒæ•´**: æ ¹æ®åé¦ˆè°ƒæ•´äº§å“æ–¹å‘

### 10.7 ç»“è®ºä¸å»ºè®®

**æ€»ä½“è¯„ä¼°**: âš ï¸ **æŠ€æœ¯å¯è¡Œï¼Œä½†éœ€å¤§å¹…è°ƒæ•´ç­–ç•¥**

**ä¸»è¦è°ƒæ•´å»ºè®®**:
1. **ç²¾ç®€MVPèŒƒå›´**: å‡å°‘AIå¤æ‚åº¦ï¼Œä¼˜å…ˆæ ¸å¿ƒä»·å€¼
2. **æ”¾ç¼“å¼€å‘èŠ‚å¥**: 24-36å‘¨å®Œæˆæ¯”12-16å‘¨æ›´ç°å®
3. **æŠ€æœ¯æ ˆåŠ¡å®**: é€‰æ‹©æ›´æ˜“ä¸Šæ‰‹çš„ç»„åˆ
4. **å¯»æ±‚å¤–éƒ¨å¸®åŠ©**: å…³é”®æŠ€æœ¯å¯è€ƒè™‘åˆä½œæˆ–å¤–åŒ…

**ç«‹å³è¡ŒåŠ¨è®¡åˆ’**:
1. **æœ¬å‘¨**: æ­å»ºåŸºç¡€å¼€å‘ç¯å¢ƒï¼Œå®Œæˆç¬¬ä¸€ä¸ªå¯æ¼”ç¤ºç‰ˆæœ¬
2. **ä¸‹å‘¨**: å®ç°è§†é¢‘ä¸Šä¼ å’ŒåŸºç¡€æ–‡å­—å¡ç‰‡åŠŸèƒ½
3. **ç¬¬ä¸‰å‘¨**: æ·»åŠ å¯¼å‡ºåŠŸèƒ½ï¼Œå½¢æˆå®Œæ•´é—­ç¯

**æ ¸å¿ƒæé†’**: ä¸€äººå¼€å‘æœ€å¤§çš„æ•Œäººæ˜¯"å®Œç¾ä¸»ä¹‰"å’Œ"èŒƒå›´è”“å»¶"ã€‚ä¿æŒç®€å•ï¼Œå¿«é€Ÿäº¤ä»˜ï¼ŒæŒç»­æ”¹è¿›æ‰æ˜¯ç‹é“ã€‚

---

**ä¸€äººå¼€å‘ç‰ˆæœ¬è¯„ä¼°**: v1.0
**è¯„ä¼°æ—¥æœŸ**: 2026-01-04
**è°ƒæ•´ç­–ç•¥**: å¤§å¹…ç²¾ç®€MVPï¼Œå»¶é•¿å‘¨æœŸï¼Œç¡®ä¿è´¨é‡

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**æœ€åæ›´æ–°**: 2026-01-04
**å®¡æ ¸çŠ¶æ€**: å¾…å®¡æ ¸
**ä¸‹ä¸€ç‰ˆæœ¬è®¡åˆ’**: æ ¹æ®åŸå‹å¼€å‘ç»“æœæ›´æ–°æŠ€æœ¯ç»†èŠ‚
