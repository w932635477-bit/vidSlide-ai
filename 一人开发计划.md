# VidSlide AI - 一人开发计划

## 概述

**项目**: VidSlide AI - 视频转PPT智能工具
**开发者**: 独立开发者
**目标**: 用24-36周时间完成可上线的MVP产品
**核心理念**: 保持简单，快速迭代，用户价值优先

---

## 一、开发原则

### 1.1 精简至上
- **功能最小化**: 只做最核心的功能
- **技术简化**: 选择最易实现的方案
- **范围控制**: 坚决避免功能蔓延

### 1.2 快速迭代
- **每周交付**: 每周至少有一个可演示的版本
- **用户反馈**: 早期获取真实用户反馈
- **持续改进**: 基于数据不断优化

### 1.3 质量优先
- **代码整洁**: 重视可维护性
- **测试覆盖**: 核心功能必须测试
- **性能监控**: 内置性能监控

---

## 二、MVP功能定义

### 核心功能 (Must Have)
1. **视频上传**: 支持MP4文件上传
2. **时间轴编辑**: 可在视频时间线上添加卡片
3. **文字卡片**: 添加文字说明和要点
4. **画中画效果**: 基础画中画功能
5. **导出功能**: 生成带字幕的视频

### 增强功能 (Should Have)
1. **语音识别**: 转写视频音频为文字
2. **智能建议**: 基于内容推荐卡片
3. **素材库**: 基础图标和背景
4. **模板系统**: 预设的卡片样式

### 锦上添花 (Nice to Have)
1. **人脸跟踪**: 画中画智能跟随
2. **外部素材**: API集成获取图片
3. **多格式导出**: HTML/PDF等格式
4. **用户系统**: 账号和作品管理

---

## 三、技术栈选择

### 前端框架
```json
{
  "框架": "Vue 3 + Composition API",
  "理由": "响应式开发效率高，生态成熟",
  "替代方案": "React (如果更熟悉)",
  "学习成本": "中等"
}
```

### UI组件库
```json
{
  "组件库": "Element Plus",
  "理由": "Vue 3原生支持，开箱即用",
  "样式方案": "Tailwind CSS (快速布局)",
  "图标": "Lucide Icons (现代简洁)"
}
```

### 状态管理
```json
{
  "方案": "Pinia",
  "理由": "Vue 3官方推荐，轻量简单",
  "数据持久化": "本地存储"
}
```

### 构建工具
```json
{
  "工具": "Vite",
  "理由": "开发体验好，构建速度快",
  "部署": "Vercel/Netlify (免费)"
}
```

### AI能力
```json
{
  "语音识别": "Web Speech API (浏览器原生)",
  "文本分析": "compromise.js (轻量NLP)",
  "图像处理": "Canvas API + 简单算法",
  "备选": "第三方API (如百度AI)"
}
```

---

## 四、分阶段开发计划

### 阶段一: 基础原型 (4-6周)

#### Week 1-2: 基础框架搭建
**目标**: 可运行的基础应用
```
✅ 项目初始化 (Vue 3 + Vite)
✅ 基础UI布局 (头部、侧边栏、主内容区)
✅ 视频上传组件 (拖拽上传)
✅ 基础路由和页面结构
✅ 响应式设计适配
```

**技术要点**:
- Vue 3项目搭建
- 文件上传处理
- 基础UI组件

**验收标准**:
- [ ] 应用可正常启动
- [ ] 视频文件可上传
- [ ] 基础界面美观

#### Week 3-4: 视频播放和编辑
**目标**: 视频播放 + 基础编辑功能
```
✅ 视频播放器组件
✅ 时间轴显示
✅ 添加文字卡片功能
✅ 卡片位置调整
✅ 基础预览功能
```

**技术要点**:
- HTML5 Video API
- Canvas绘制时间轴
- 拖拽交互实现

**验收标准**:
- [ ] 视频可正常播放
- [ ] 可在时间轴上添加卡片
- [ ] 卡片可调整位置和内容

#### Week 5-6: 画中画和导出
**目标**: 核心功能闭环
```
✅ 画中画效果实现
✅ 视频合成预览
✅ 基础导出功能 (截图/PDF)
✅ UI优化和Bug修复
```

**技术要点**:
- Canvas合成技术
- 视频截图导出
- PDF生成库

**验收标准**:
- [ ] 画中画效果正常
- [ ] 可导出带字幕的截图
- [ ] 整体流程流畅

### 阶段二: AI增强 (6-8周)

#### Week 7-10: 语音识别集成
**目标**: 添加智能功能
```
✅ 语音转文字 (Web Speech API)
✅ 文字显示和编辑
✅ 关键词自动提取
✅ 智能卡片建议
```

**技术要点**:
- Web Speech API集成
- 音频处理
- 文本分析算法

**验收标准**:
- [ ] 可识别中文语音
- [ ] 自动生成相关卡片
- [ ] 识别准确率>80%

#### Week 11-14: 模板和素材
**目标**: 提升专业度
```
✅ 预设模板系统
✅ 基础素材库
✅ 模板智能推荐
✅ 用户界面优化
```

**技术要点**:
- JSON配置的模板系统
- 本地素材管理
- 规则引擎推荐

**验收标准**:
- [ ] 5个以上专业模板
- [ ] 素材库包含100+图标
- [ ] 模板推荐准确

### 阶段三: 完善上线 (6-8周)

#### Week 15-18: 高级功能
**目标**: 完整产品体验
```
✅ 外部素材集成 (可选)
✅ 批量导出优化
✅ 用户反馈系统
✅ 性能优化
```

**技术要点**:
- API集成设计
- 批量处理优化
- 错误处理和反馈

**验收标准**:
- [ ] 支持外部素材搜索
- [ ] 导出速度<30秒
- [ ] 无明显性能问题

#### Week 19-22: 测试和部署
**目标**: 产品上线准备
```
✅ 全面测试 (功能/性能/兼容性)
✅ 用户系统 (基础版)
✅ 部署上线
✅ 监控和分析
```

**技术要点**:
- 自动化测试
- 部署配置
- 分析工具集成

**验收标准**:
- [ ] 通过所有核心测试
- [ ] 成功部署到生产环境
- [ ] 有基本的用户数据收集

---

## 五、技术实现重点

### 5.1 核心组件设计

#### 视频编辑器组件
```javascript
// VideoEditor.vue
<template>
  <div class="video-editor">
    <!-- 视频播放器 -->
    <video ref="videoPlayer" @timeupdate="onTimeUpdate"></video>

    <!-- 时间轴 -->
    <Timeline
      :duration="duration"
      :currentTime="currentTime"
      :markers="markers"
      @marker-add="addMarker"
      @marker-update="updateMarker"
    />

    <!-- 编辑面板 -->
    <EditPanel
      v-model="selectedMarker"
      @save="saveMarker"
      @delete="deleteMarker"
    />

    <!-- 预览画布 -->
    <canvas ref="previewCanvas" class="preview-canvas"></canvas>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'
import Timeline from './Timeline.vue'
import EditPanel from './EditPanel.vue'

// 响应式数据
const videoPlayer = ref(null)
const previewCanvas = ref(null)
const currentTime = ref(0)
const duration = ref(0)
const markers = ref([])
const selectedMarker = ref(null)

// 计算属性
const progress = computed(() => currentTime.value / duration.value * 100)

// 方法
const onTimeUpdate = () => {
  currentTime.value = videoPlayer.value.currentTime
  updatePreview()
}

const addMarker = (time) => {
  const marker = {
    id: generateId(),
    time,
    type: 'text',
    content: '',
    position: { x: 50, y: 50 },
    style: 'default'
  }
  markers.value.push(marker)
}

const updatePreview = () => {
  const ctx = previewCanvas.value.getContext('2d')
  // 绘制当前时间的预览
  renderPreviewAtTime(ctx, currentTime.value)
}
</script>
```

#### 时间轴组件
```javascript
// Timeline.vue
<template>
  <div class="timeline" ref="timelineRef">
    <div class="timeline-header">
      <div class="time-markers">
        <div
          v-for="marker in timeMarkers"
          :key="marker"
          class="time-marker"
          :style="{ left: marker.position + '%' }"
        >
          {{ marker.label }}
        </div>
      </div>
    </div>

    <div class="timeline-body" @click="onTimelineClick">
      <div class="timeline-track">
        <!-- 卡片标记 -->
        <div
          v-for="marker in markers"
          :key="marker.id"
          class="marker"
          :class="{ selected: marker.id === selectedMarkerId }"
          :style="{ left: getMarkerPosition(marker) + '%' }"
          @click.stop="selectMarker(marker)"
        >
          <div class="marker-content">{{ marker.content.substring(0, 10) }}</div>
        </div>

        <!-- 当前时间指示器 -->
        <div class="current-time-indicator" :style="{ left: currentProgress + '%' }"></div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue'

const props = defineProps({
  duration: Number,
  currentTime: Number,
  markers: Array
})

const emit = defineEmits(['marker-add', 'marker-select'])

const timelineRef = ref(null)
const selectedMarkerId = ref(null)

// 计算时间标记
const timeMarkers = computed(() => {
  const markers = []
  for (let i = 0; i <= props.duration; i += 30) { // 每30秒一个标记
    markers.push({
      time: i,
      label: formatTime(i),
      position: (i / props.duration) * 100
    })
  }
  return markers
})

const currentProgress = computed(() =>
  (props.currentTime / props.duration) * 100
)

const onTimelineClick = (event) => {
  const rect = timelineRef.value.getBoundingClientRect()
  const x = event.clientX - rect.left
  const percentage = x / rect.width
  const time = percentage * props.duration

  emit('marker-add', time)
}

const selectMarker = (marker) => {
  selectedMarkerId.value = marker.id
  emit('marker-select', marker)
}

const getMarkerPosition = (marker) => {
  return (marker.time / props.duration) * 100
}

const formatTime = (seconds) => {
  const mins = Math.floor(seconds / 60)
  const secs = Math.floor(seconds % 60)
  return `${mins}:${secs.toString().padStart(2, '0')}`
}
</script>
```

### 5.2 AI功能简化实现

#### 语音识别集成
```javascript
class SpeechService {
  constructor() {
    this.recognition = null
    this.isSupported = 'webkitSpeechRecognition' in window
    this.init()
  }

  init() {
    if (!this.isSupported) return

    this.recognition = new webkitSpeechRecognition()
    this.recognition.continuous = true
    this.recognition.interimResults = true
    this.recognition.lang = 'zh-CN' // 默认中文

    this.recognition.onresult = this.onResult.bind(this)
    this.recognition.onend = this.onEnd.bind(this)
    this.recognition.onerror = this.onError.bind(this)
  }

  start() {
    if (!this.recognition) return
    this.recognition.start()
  }

  stop() {
    if (!this.recognition) return
    this.recognition.stop()
  }

  onResult(event) {
    let finalTranscript = ''
    let interimTranscript = ''

    for (let i = event.resultIndex; i < event.results.length; i++) {
      const transcript = event.results[i][0].transcript
      if (event.results[i].isFinal) {
        finalTranscript += transcript
      } else {
        interimTranscript += transcript
      }
    }

    // 通知父组件
    this.emit('transcript', {
      final: finalTranscript,
      interim: interimTranscript
    })
  }

  onEnd() {
    // 自动重启以保持连续识别
    setTimeout(() => this.start(), 100)
  }

  onError(error) {
    console.error('Speech recognition error:', error)
    // 可以在这里实现重试逻辑
  }
}
```

#### 关键词提取
```javascript
class KeywordExtractor {
  constructor() {
    // 中文停用词
    this.stopWords = new Set([
      '的', '了', '和', '是', '就', '都', '而', '及', '与', '着',
      '或', '一个', '没有', '我们', '你们', '他们', '这个', '那个',
      '这样', '那样', '这里', '那里', '现在', '然后', '但是'
    ])
  }

  extract(text, maxKeywords = 5) {
    // 1. 分词 (使用简单规则分词)
    const words = this.tokenize(text)

    // 2. 过滤停用词
    const filteredWords = words.filter(word => !this.stopWords.has(word))

    // 3. 词频统计
    const wordFreq = {}
    filteredWords.forEach(word => {
      wordFreq[word] = (wordFreq[word] || 0) + 1
    })

    // 4. 按词频排序
    const sortedWords = Object.entries(wordFreq)
      .sort((a, b) => b[1] - a[1])
      .slice(0, maxKeywords)
      .map(([word, freq]) => ({ word, frequency: freq }))

    return sortedWords
  }

  tokenize(text) {
    // 简化的中文分词实现
    // 在实际项目中可以集成更专业的分词库
    const words = []
    let current = ''

    for (let i = 0; i < text.length; i++) {
      const char = text[i]

      if (this.isChinese(char) || this.isEnglish(char)) {
        current += char
      } else {
        if (current) {
          words.push(current)
          current = ''
        }
      }
    }

    if (current) {
      words.push(current)
    }

    return words
  }

  isChinese(char) {
    return /[\u4e00-\u9fa5]/.test(char)
  }

  isEnglish(char) {
    return /[a-zA-Z]/.test(char)
  }
}
```

---

## 六、质量保证

### 6.1 开发规范

#### 代码规范
```json
{
  "ESLint": "Vue 3推荐配置",
  "Prettier": "自动代码格式化",
  "TypeScript": "可选，用于复杂逻辑",
  "Git": "规范的提交信息"
}
```

#### 组件规范
```javascript
// 每个组件都应该包含
// 1. 清晰的props定义
// 2. 完整的emit声明
// 3. 必要的错误处理
// 4. 性能优化 (computed缓存等)

// 示例组件结构
export default {
  name: 'ComponentName',
  props: {
    // 明确定义所有props
  },
  emits: [
    // 明确声明所有emit事件
  ],
  setup(props, { emit }) {
    // 组合式API逻辑
  }
}
```

### 6.2 测试策略

#### 单元测试
```javascript
// 使用Vitest进行单元测试
import { describe, it, expect } from 'vitest'
import { mount } from '@vue/test-utils'
import VideoEditor from '../components/VideoEditor.vue'

describe('VideoEditor', () => {
  it('should render video player', () => {
    const wrapper = mount(VideoEditor)
    expect(wrapper.find('video').exists()).toBe(true)
  })

  it('should add marker on timeline click', async () => {
    const wrapper = mount(VideoEditor)
    const timeline = wrapper.find('.timeline')

    await timeline.trigger('click')

    expect(wrapper.vm.markers.length).toBe(1)
  })
})
```

#### 集成测试
- 核心用户流程测试
- 跨浏览器兼容性测试
- 性能基准测试

### 6.3 部署和监控

#### 部署策略
```json
{
  "平台": "Vercel/Netlify",
  "理由": "免费，自动部署，CDN加速",
  "监控": "内置错误收集",
  "分析": "Google Analytics"
}
```

#### 性能监控
```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = {}
    this.init()
  }

  init() {
    // 监听性能指标
    if ('PerformanceObserver' in window) {
      this.observeLCP()
      this.observeFID()
      this.observeCLS()
    }
  }

  observeLCP() {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      const lastEntry = entries[entries.length - 1]
      this.metrics.lcp = lastEntry.startTime
    })
    observer.observe({ entryTypes: ['largest-contentful-paint'] })
  }

  reportMetrics() {
    // 发送到监控服务
    console.log('Performance Metrics:', this.metrics)
  }
}
```

---

## 七、风险控制

### 7.1 技术风险

#### 高风险项目应对
1. **AI功能失败**: 准备降级方案，纯手动模式
2. **浏览器兼容性**: 渐进增强，从Chrome开始
3. **性能问题**: 实时监控，及时优化

#### 备选方案
```javascript
// 如果Web Speech API不支持
const SpeechFallback = {
  // 使用第三方服务或纯手动输入
  async recognize(audioBlob) {
    // 显示文字输入框，让用户手动输入
    return new Promise(resolve => {
      const text = prompt('请输入视频中的文字内容:')
      resolve(text)
    })
  }
}

// 如果Canvas性能不足
const CanvasFallback = {
  // 使用DOM元素代替Canvas渲染
  renderMarkers(markers) {
    const container = document.createElement('div')
    markers.forEach(marker => {
      const element = document.createElement('div')
      element.className = 'marker-overlay'
      element.style.left = marker.position.x + '%'
      element.style.top = marker.position.y + '%'
      element.textContent = marker.content
      container.appendChild(element)
    })
    return container
  }
}
```

### 7.2 项目风险

#### 时间管理
- **每周目标**: 设定合理的小目标
- **进度跟踪**: 使用GitHub Projects或Trello
- **定期review**: 每周复盘，调整计划

#### 动力维持
- **成就感**: 庆祝每个小里程碑
- **社区参与**: 加入相关技术社区
- **用户反馈**: 让真实用户使用你的产品

---

## 八、资源需求

### 8.1 开发环境

#### 必备工具
```json
{
  "IDE": "VS Code + Vue插件",
  "版本控制": "Git + GitHub",
  "包管理": "npm/yarn",
  "浏览器": "Chrome + DevTools",
  "设计": "Figma (免费版)"
}
```

#### 推荐学习资源
```json
{
  "Vue 3": "官方文档 + Vue Mastery课程",
  "Canvas API": "MDN文档 + 实践项目",
  "Web Audio": "Web Audio API指南",
  "性能优化": "Web.dev + 相关文章"
}
```

### 8.2 第三方服务

#### 免费额度
```json
{
  "部署平台": "Vercel (100GB/月)",
  "数据库": "Supabase (500MB免费)",
  "文件存储": "Cloudinary (25GB免费)",
  "分析": "Google Analytics (免费)"
}
```

#### 付费服务 (按需)
```json
{
  "语音识别": "百度AI/腾讯AI (¥)",
  "图片素材": "Unsplash API (部分免费)",
  "监控": "Sentry (免费额度足够)"
}
```

---

## 九、成功指标

### 9.1 技术指标

#### MVP完成标准
- [ ] 核心功能完整实现
- [ ] 性能满足基本要求
- [ ] 代码质量可维护
- [ ] 浏览器兼容性良好

#### 用户体验指标
- [ ] 任务完成时间 < 5分钟
- [ ] 用户满意度 > 80%
- [ ] 错误率 < 5%
- [ ] 加载时间 < 3秒

### 9.2 商业指标

#### 初期目标
- [ ] 10个种子用户
- [ ] 用户留存率 > 70%
- [ ] 每月活跃用户增长
- [ ] 正面反馈占比 > 80%

---

## 十、结语

**记住**: 这是一个长期项目，保持耐心和坚持是最重要的品质。

**核心理念**: 
1. **用户价值优先**: 解决真实问题
2. **技术务实**: 选择合适的技术方案
3. **持续改进**: 基于反馈不断优化
4. **享受过程**: 编程应该是快乐的

**行动起来**: 从今天开始，迈出第一步！

---

**文档版本**: 1.0
**最后更新**: 2026-01-04
**状态**: 待执行
